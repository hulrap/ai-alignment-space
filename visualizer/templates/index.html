<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AI Alignment 3D Visualization</title>
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <!-- Google Fonts - Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- TWEEN.js for smooth animations -->
    <script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.umd.js" 
            crossorigin="anonymous"></script>
    <!-- Our CSS -->
    <link rel="stylesheet" href="/static/styles.css">
    <!-- Node details renderer -->
    <script src="/static/node_details_renderer.js"></script>
    
    <!-- Sound toggle button styling -->
    <style>
        .sound-toggle {
            font-size: 18px;
            padding: 8px 12px;
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid #00ff41;
            color: #00ff41;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .sound-toggle:hover {
            background: rgba(0, 255, 65, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
        }
        
        .sound-toggle.muted {
            background: rgba(255, 100, 100, 0.1);
            border-color: #ff6464;
            color: #ff6464;
        }
        
        .sound-toggle.muted:hover {
            background: rgba(255, 100, 100, 0.2);
            box-shadow: 0 0 10px rgba(255, 100, 100, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Visualization area -->
        <div id="visualization-container">
            <div id="scene-container"></div>
            
            <!-- Controls -->
            <div class="controls">
                <button id="zoom-in">Zoom In</button>
                <button id="zoom-out">Zoom Out</button>
                <button id="reset-view">Reset View</button>
                <button id="toggle-rotation">Rotate</button>
                <button id="expand-all">Expand All</button>
                <button id="collapse-all">Collapse All</button>
                <button id="toggle-sound" class="sound-toggle">🔊</button>
                <button id="toggle-fullscreen" class="fullscreen-toggle">⛶</button>
                <button id="toggle-panel" class="panel-toggle">
                    <span class="lightning"></span>
                    <span class="lightning"></span>
                    <span class="lightning"></span>
                    <span class="spark"></span>
                    <span class="spark"></span>
                    <span class="spark"></span>
                    <span class="spark"></span>
                    Info
                </button>
                <button id="toggle-legend" class="panel-toggle">Node Types</button>
                <button id="toggle-help" class="panel-toggle">Help</button>
            </div>
            
            <!-- Legend -->
            <div class="legend hidden" id="legend-panel">
                <div class="legend-item">
                    <span class="legend-color component-group"></span>
                    <span>Component Group</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color component"></span>
                    <span>Component</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color subcomponent"></span>
                    <span>Subcomponent</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color capability"></span>
                    <span>Capability</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color function"></span>
                    <span>Function</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color specification"></span>
                    <span>Specification</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color integration"></span>
                    <span>Integration</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color technique"></span>
                    <span>Technique</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color application"></span>
                    <span>Application</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color input"></span>
                    <span>Input</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color output"></span>
                    <span>Output</span>
                </div>
            </div>
            
            <!-- Help Panel -->
            <div class="help-panel hidden" id="help-panel">
                <div class="help-header">
                    <h3>Navigation & Controls</h3>
                </div>
                
                <div class="help-section">
                    <h4>Mouse Controls</h4>
                    <div class="help-content">
                        <div class="help-item">
                            <span class="help-action">Click Node</span>
                            <span class="help-description">Select and expand/collapse nodes, view details</span>
                        </div>
                        <div class="help-item">
                            <span class="help-action">Double-Click Empty Space</span>
                            <span class="help-description">Deselect current node</span>
                        </div>
                        <div class="help-item">
                            <span class="help-action">Hover</span>
                            <span class="help-description">Preview node name and type</span>
                        </div>
                        <div class="help-item">
                            <span class="help-action">Drag</span>
                            <span class="help-description">Rotate the sphere in 3D space</span>
                        </div>
                        <div class="help-item">
                            <span class="help-action">Scroll</span>
                            <span class="help-description">Zoom in and out</span>
                        </div>
                    </div>
                </div>
                
                <div class="help-section">
                    <h4>Control Buttons</h4>
                    <div class="help-content">
                        <div class="help-item">
                            <span class="help-action">Zoom In/Out</span>
                            <span class="help-description">Adjust camera distance</span>
                        </div>
                        <div class="help-item">
                            <span class="help-action">Reset View</span>
                            <span class="help-description">Return to default position</span>
                        </div>
                        <div class="help-item">
                            <span class="help-action">Rotate</span>
                            <span class="help-description">Toggle automatic rotation</span>
                        </div>
                        <div class="help-item">
                            <span class="help-action">Expand All</span>
                            <span class="help-description">Show all nodes in hierarchy</span>
                        </div>
                        <div class="help-item">
                            <span class="help-action">Collapse All</span>
                            <span class="help-description">Hide all except root node</span>
                        </div>
                        <div class="help-item">
                            <span class="help-action">Fullscreen</span>
                            <span class="help-description">Toggle fullscreen mode</span>
                        </div>
                    </div>
                </div>
                
                <div class="help-section">
                    <h4>Information Panels</h4>
                    <div class="help-content">
                        <div class="help-item">
                            <span class="help-action">Info Panel</span>
                            <span class="help-description">View detailed node information</span>
                        </div>
                        <div class="help-item">
                            <span class="help-action">Node Types</span>
                            <span class="help-description">Show color-coded legend</span>
                        </div>
                        <div class="help-item">
                            <span class="help-action">Breadcrumbs</span>
                            <span class="help-description">Navigate through node hierarchy</span>
                        </div>
                    </div>
                </div>
                
                <div class="help-section">
                    <h4>Audio & Effects</h4>
                    <div class="help-content">
                        <div class="help-item">
                            <span class="help-action">Sound Toggle</span>
                            <span class="help-description">Enable/disable audio feedback</span>
                        </div>
                        <div class="help-item">
                            <span class="help-action">Click Sounds</span>
                            <span class="help-description">Feedback for node selection</span>
                        </div>
                    </div>
                </div>
                
                <div class="help-section">
                    <h4>Tips</h4>
                    <div class="help-content">
                        <div class="help-tip">
                            <span class="tip-text">Click on any node with children to explore deeper levels</span>
                        </div>
                        <div class="help-tip">
                            <span class="tip-text">Use breadcrumbs to quickly navigate back to parent nodes</span>
                        </div>
                        <div class="help-tip">
                            <span class="tip-text">Combine rotation with zoom for cinematic exploration</span>
                        </div>
                        <div class="help-tip">
                            <span class="tip-text">Node colors indicate their type and function in the system</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Details panel -->
        <div id="details-panel">
            <div class="details-header">
                <div class="header-row">
                    <button id="back-button" class="back-button hidden">
                        <span class="back-arrow">←</span> Back
                    </button>
                    <div class="welcome-header-title">
                        <div class="cosmic-title">
                            <h2>AI Alignment Space</h2>
                            <div class="subtitle">An Artistic Exploration of Automated Conceptual Co-Creation</div>
                        </div>
                        <div class="orbital-decoration">
                            <div class="orbit-ring"></div>
                            <div class="orbit-ring orbit-ring-2"></div>
                            <div class="orbit-ring orbit-ring-3"></div>
                        </div>
                    </div>
                </div>
                <div id="breadcrumb-navigation" class="breadcrumb-container"></div>
                <div class="global-controls">
                    <!-- Expand All button removed from details panel -->
                </div>
            </div>
            <!-- Make this a single scrollable container that includes both content and literature -->
            <div class="single-scrollable-container">
                <div id="details-content"></div>
                <!-- Remove the permanent literature section as it's created dynamically by the node renderer -->
            </div>
        </div>
    </div>

    <!-- Three.js import map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/"
            }
        }
    </script>

    <!-- Main visualization script -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';
        
        // Main visualization class
        class AIAlignmentVisualization {
            constructor() {
                // Make the visualization accessible globally for click handlers
                window.visualization = this;
                
                // Core THREE.js components
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                
                // Interaction and physics
                this.raycaster = null;
                this.mouse = null;
                this.clock = new THREE.Clock();
                
                // Graph data storage
                this.graphData = null;
                this.nodeDetails = new Map();
                
                // Visualization objects
                this.nodes = new Map();           // THREE.js meshes by node ID
                this.links = new Map();           // THREE.js line objects
                this.nodePositions = new Map();   // Current 3D positions of nodes
                this.expandedNodes = new Set();   // Tracks which nodes are expanded
                this.nodeAnimations = new Map();  // Animation properties for nodes
                this.nodeOrbits = new Map();      // Orbital patterns for child nodes
                
                // Navigation history
                this.navigationHistory = [];      // Stack of previously visited nodes
                this.currentNodeIndex = -1;       // Index in history of current node
                this.scrollPositions = new Map(); // Map of node IDs to scroll positions
                
                // State management
                this.selectedNode = null;
                this.hoveredNode = null;
                this.currentTargetNode = null;    // Currently targeted node for sounds
                this.soundEnabled = true;         // Sound on/off state
                this.audioConfig = null;          // Audio configuration from server
                this.audioFiles = {};             // Loaded audio files
                this.backgroundAudio = null;      // Background music audio element
                this.lastHoverSoundTime = 0;      // Timestamp of last hover sound
                this.hoverSoundCooldown = 50;     // Minimum ms between hover sounds
                this.isRotating = false;
                this.isFullscreen = false;        // Tracks fullscreen state
                this.isActive = true;             // Controls if animation loop runs
                this.animationRunning = false;    // Tracks if animation has started
                this._processingExpansion = false; // Prevents concurrent expand/collapse operations
                this.lastFrameTime = null;        // For delta time calculation in rotation
                this.hasUserInteracted = false;   // Track if user has interacted with the page
                this.musicStarted = false;        // Track if background music has started successfully
                this.musicErrorLogged = false;    // Track if we've logged music errors to avoid spam
                this.musicAlreadyPlayingLogged = false; // Track if we've logged "already playing" message
                
                // Double-click tracking for deselection
                this.lastClickTime = 0;
                this.doubleClickThreshold = 300;  // milliseconds
                
                // Performance
                this.frustumCulled = false; // Start with culling disabled for testing
                
                // Initialize the visualization
                this.init();
                this.setupEventListeners(); // Set up UI event listeners
                
                // Ensure panel state is correct after renderer creation
                this.initializePanelState();
                
                this.loadData();
                
                // Update sound button after audio system is initialized
                setTimeout(() => {
                    this.updateSoundButton();
                    this.updateRotationButton();
                    this.updateFullscreenButton();
                    this.setupFullscreenListeners();
                }, 100);
            }
            
            init() {
                // Get container element
                this.container = document.getElementById('scene-container');
                if (!this.container) {
                    // Fallback to body if container not found
                    console.error("Container element 'scene-container' not found, using body as fallback");
                    this.container = document.body;
                    // Create a container div if using body as fallback
                    const containerDiv = document.createElement('div');
                    containerDiv.id = 'scene-container';
                    containerDiv.style.width = '100%';
                    containerDiv.style.height = '100vh';
                    document.body.appendChild(containerDiv);
                    this.container = containerDiv;
                }
                
                // Get container dimensions using getBoundingClientRect for accuracy
                const rect = this.container.getBoundingClientRect();
                const width = rect.width || window.innerWidth;
                const height = rect.height || window.innerHeight;
                
                // Initialize scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x111111);
                
                // Initialize camera
                this.camera = new THREE.PerspectiveCamera(
                    60, 
                    width / height, 
                    1, 
                    10000
                );
                this.camera.position.z = 1000;
                
                // Initialize renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(width, height);
                this.container.appendChild(this.renderer.domElement);
                
                // Initialize controls
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                // Initialize raycaster for mouse interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                // Create hover display
                this.hoverDisplay = this.createHoverDisplay();
                
                // Initialize audio system for targeting sounds
                this.initializeAudioSystem();
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);
                
                // Create spherical container
                this.createSphericalContainer();
                
                // Set up window resize handler
                window.addEventListener('resize', () => this.onWindowResize());
                
                console.log("Visualization initialized");
            }
            
            // Method to properly start animation loop
            startAnimation() {
                if (!this.animationRunning) {
                    this.isActive = true;
                    this.animationRunning = true;
                    this.animate();
                    console.log("Animation loop started");
                }
            }
            
            // Method to properly stop animation loop
            stopAnimation() {
                this.isActive = false;
                this.animationRunning = false;
                console.log("Animation loop stopped");
            }
            
            loadData() {
                fetch('/api/graph')
                    .then(response => response.json())
                    .then(data => {
                        this.processData(data);
                        
                        // Find the root node initially
                        const rootNode = this.graphData.nodes.find(node => !node.parent);
                        if (rootNode) {
                            // Only expand the root node initially, not its children
                            this.expandedNodes.add(rootNode.id);
                        }
                        
                        // Get initially visible nodes
                        const visibleNodes = this.getVisibleNodes();
                        
                        // Position nodes based on hierarchy
                        this.positionNodes(visibleNodes);
                        
                        // Create visualization objects
                        this.createNodeObjects(visibleNodes);
                        this.createLinkObjects(this.getVisibleLinks(visibleNodes));
                        
                        // Set up node animations
                        this.setupNodeOrbits(visibleNodes);
                        
                        // Start animation loop
                        this.startAnimation();
                        
                        // Try to start background music once everything is loaded
                        setTimeout(() => {
                            this.ensureBackgroundMusicStarted();
                        }, 1000);
                    })
                    .catch(error => console.error('Error loading data:', error));
            }
            
            processData(data) {
                console.log("Processing graph data:", data);
                
                // Store the graph data
                this.graphData = data;
                
                // Validate and normalize the data
                if (!this.graphData.nodes) {
                    console.error("Invalid graph data: missing nodes array");
                    this.graphData.nodes = [];
                }
                
                if (!this.graphData.links) {
                    console.error("Invalid graph data: missing links array");
                    this.graphData.links = [];
                }
                
                // Normalize links to ensure source and target are properly set
                this.graphData.links.forEach(link => {
                    if (typeof link.source === 'object' && link.source !== null) {
                        link.source = link.source.id || link.source;
                    }
                    
                    if (typeof link.target === 'object' && link.target !== null) {
                        link.target = link.target.id || link.target;
                    }
                });
                
                console.log(`Processed ${this.graphData.nodes.length} nodes and ${this.graphData.links.length} links`);
            }
            
            createHoverDisplay() {
                // Create the hover display element
                const hoverDisplay = document.createElement('div');
                hoverDisplay.id = 'hover-node-name';
                document.body.appendChild(hoverDisplay);
                
                // Set initial state
                hoverDisplay.style.opacity = '0';
                hoverDisplay.style.display = 'none';
                
                return hoverDisplay;
            }
            

            
            async initializeAudioSystem() {
                // Load audio configuration from server
                try {
                    const response = await fetch('/api/audio-config');
                    this.audioConfig = await response.json();
                    console.log("Audio config loaded:", this.audioConfig);
                } catch (error) {
                    console.warn("Failed to load audio config, using fallback:", error);
                    this.audioConfig = {
                        fallback_to_generated: true,
                        volume: 0.3,
                        enabled_by_default: true
                    };
                }
                
                // Set initial sound state
                this.soundEnabled = this.audioConfig.enabled_by_default;
                
                // Try to load audio files
                await this.loadAudioFiles();
                
                // Create audio context for fallback sounds
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.audioEnabled = true;
                    console.log("Audio system initialized");
                } catch (error) {
                    console.warn("Audio not available:", error);
                    this.audioEnabled = false;
                }
            }
            
            async loadAudioFiles() {
                if (!this.audioConfig) return;
                
                const audioPromises = [];
                
                // Load hover sound (only if enabled)
                if (this.audioConfig.hover_sound && this.audioConfig.hover_sounds_enabled) {
                    audioPromises.push(
                        this.loadAudioFile('hover', this.audioConfig.hover_sound)
                    );
                }
                
                // Load click sound (only if enabled)
                if (this.audioConfig.click_sound && this.audioConfig.click_sounds_enabled) {
                    audioPromises.push(
                        this.loadAudioFile('click', this.audioConfig.click_sound)
                    );
                }
                
                // Load background music (only if enabled)
                if (this.audioConfig.background_sound && this.audioConfig.background_music_enabled) {
                    audioPromises.push(
                        this.loadBackgroundAudio(this.audioConfig.background_sound)
                    );
                }
                
                // Wait for all audio files to load (or fail)
                await Promise.allSettled(audioPromises);
                
                console.log("Audio files loaded:", Object.keys(this.audioFiles));
                
                // Start background music if sound is enabled
                if (this.soundEnabled && this.backgroundAudio) {
                    this.startBackgroundMusic();
                }
            }
            
            async loadAudioFile(key, url) {
                try {
                    // Create a pool of audio instances for immediate playback
                    const audioPool = [];
                    const poolSize = key === 'click' ? 8 : 4; // More instances for click sounds to reduce delay
                    
                    for (let i = 0; i < poolSize; i++) {
                        const audio = new Audio(url);
                        audio.volume = this.audioConfig.volume || 0.3;
                        audio.preload = 'auto';
                        
                        // Wait for the audio to be ready
                        await new Promise((resolve, reject) => {
                            audio.addEventListener('canplaythrough', resolve);
                            audio.addEventListener('error', reject);
                            audio.load();
                        });
                        
                        audioPool.push(audio);
                    }
                    
                    // Store the pool and add a method to get next available instance
                    this.audioFiles[key] = {
                        pool: audioPool,
                        currentIndex: 0,
                        getNext: function() {
                            const audio = this.pool[this.currentIndex];
                            this.currentIndex = (this.currentIndex + 1) % this.pool.length;
                            return audio;
                        }
                    };
                    
                    console.log(`Audio file pool loaded: ${key} from ${url} (${poolSize} instances)`);
                } catch (error) {
                    console.warn(`Failed to load audio file ${key} from ${url}:`, error);
                }
            }
            
            async loadBackgroundAudio(url) {
                try {
                    const audio = new Audio(url);
                    audio.volume = this.audioConfig.background_volume || 0.15;
                    audio.loop = true; // Background music should loop
                    audio.preload = 'auto';
                    
                    // Wait for the audio to be ready
                    await new Promise((resolve, reject) => {
                        audio.addEventListener('canplaythrough', resolve);
                        audio.addEventListener('error', reject);
                        audio.load();
                    });
                    
                    this.backgroundAudio = audio;
                    console.log(`Background audio loaded from ${url}`);
                } catch (error) {
                    console.warn(`Failed to load background audio from ${url}:`, error);
                    this.backgroundAudio = null;
                }
            }
            
            toggleSound() {
                this.soundEnabled = !this.soundEnabled;
                this.updateSoundButton();
                
                // Control background music based on sound state
                if (this.soundEnabled) {
                    this.startBackgroundMusic();
                } else {
                    this.stopBackgroundMusic();
                }
            }
            
            startBackgroundMusic() {
                if (!this.backgroundAudio || !this.soundEnabled) return;
                
                // Check if background music is globally disabled
                if (!this.audioConfig?.background_music_enabled) {
                    return;
                }
                
                try {
                    // Don't reset to beginning if already playing
                    if (!this.backgroundAudio.paused) {
                        // Only log once when music is already playing
                        if (!this.musicAlreadyPlayingLogged) {
                            console.log("Background music already playing");
                            this.musicAlreadyPlayingLogged = true;
                        }
                        return;
                    }
                    
                    // Only reset to beginning if we're starting fresh
                    if (this.backgroundAudio.currentTime === 0) {
                        this.backgroundAudio.currentTime = 0;
                    }
                    
                    const playPromise = this.backgroundAudio.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log("Background music started successfully");
                            this.musicStarted = true; // Mark that music has started
                            this.musicAlreadyPlayingLogged = false; // Reset for next time
                        }).catch(error => {
                            // Only log this error once per session to avoid spam
                            if (!this.musicErrorLogged) {
                                if (!this.hasUserInteracted) {
                                    console.log("Background music waiting for user interaction (this is normal browser behavior)");
                                } else {
                                    console.warn("Could not start background music:", error);
                                }
                                this.musicErrorLogged = true;
                            }
                        });
                    }
                } catch (error) {
                    if (!this.musicErrorLogged) {
                        console.warn("Error starting background music:", error);
                        this.musicErrorLogged = true;
                    }
                }
            }
            
            stopBackgroundMusic() {
                if (!this.backgroundAudio) return;
                
                try {
                    this.backgroundAudio.pause();
                    this.backgroundAudio.currentTime = 0;
                    console.log("Background music stopped");
                } catch (error) {
                    console.warn("Error stopping background music:", error);
                }
            }
            
            ensureBackgroundMusicStarted() {
                // Mark that user has interacted
                this.hasUserInteracted = true;
                
                // Only start if we have background audio, sound is enabled, and it's not already playing
                if (!this.backgroundAudio || !this.soundEnabled || this.musicStarted) return;
                
                // Try to start if paused or if we haven't attempted to start yet
                if (this.backgroundAudio.paused || this.backgroundAudio.currentTime === 0) {
                    this.startBackgroundMusic();
                }
            }
            
            updateSoundButton() {
                const toggleButton = document.getElementById('toggle-sound');
                
                if (toggleButton) {
                    if (this.soundEnabled) {
                        toggleButton.textContent = '🔊';
                        toggleButton.classList.remove('muted');
                        console.log("Sound enabled");
                    } else {
                        toggleButton.textContent = '🔇';
                        toggleButton.classList.add('muted');
                        console.log("Sound disabled");
                    }
                }
            }
            
            toggleFullscreen() {
                if (this.isFullscreen) {
                    this.exitFullscreen();
                } else {
                    this.enterFullscreen();
                }
            }
            
            enterFullscreen() {
                const element = document.documentElement;
                
                // For mobile devices, we'll use a different approach since fullscreen API is limited
                if (this.isMobileDevice()) {
                    this.enterMobileFullscreen();
                    return;
                }
                
                // Desktop fullscreen using standard API
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                } else if (element.mozRequestFullScreen) {
                    element.mozRequestFullScreen();
                } else if (element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen();
                } else if (element.msRequestFullscreen) {
                    element.msRequestFullscreen();
                }
                
                // Listen for fullscreen change events
                this.setupFullscreenListeners();
            }
            
            exitFullscreen() {
                if (this.isMobileDevice()) {
                    this.exitMobileFullscreen();
                    return;
                }
                
                // Desktop fullscreen exit
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
            
            enterMobileFullscreen() {
                // For mobile, we'll use a different approach since true fullscreen isn't reliable
                const body = document.body;
                const container = document.querySelector('.container');
                
                // Add mobile fullscreen classes
                body.classList.add('mobile-fullscreen');
                container.classList.add('mobile-fullscreen');
                
                // Try multiple approaches to hide browser UI
                this.hideMobileBrowserUI();
                
                // Set viewport meta tag for fullscreen experience
                let viewport = document.querySelector('meta[name=viewport]');
                if (viewport) {
                    viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, minimal-ui');
                }
                
                // Force the page to use full viewport height
                document.documentElement.style.height = '100vh';
                document.documentElement.style.height = '100dvh'; // Dynamic viewport height for mobile
                body.style.height = '100vh';
                body.style.height = '100dvh';
                
                // Hide any scrollbars
                body.style.overflow = 'hidden';
                document.documentElement.style.overflow = 'hidden';
                
                this.isFullscreen = true;
                this.updateFullscreenButton();
                
                // Set up resize listener for mobile viewport changes
                this.setupMobileResizeListener();
                
                // Trigger resize after a short delay to ensure everything is applied
                setTimeout(() => {
                    this.onWindowResize();
                    // Try to hide browser UI again after layout changes
                    this.hideMobileBrowserUI();
                }, 100);
                
                console.log("Entered mobile fullscreen mode");
            }
            
            hideMobileBrowserUI() {
                // Multiple techniques to hide mobile browser UI
                
                // Method 1: Calculate and set proper viewport height
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
                
                // Method 2: Platform-specific approaches
                if (this.isIOSDevice()) {
                    // iOS-specific approach
                    this.hideIOSBrowserUI();
                } else if (this.isAndroidDevice()) {
                    // Android-specific approach
                    this.hideAndroidBrowserUI();
                } else {
                    // Generic mobile approach
                    this.hideGenericMobileBrowserUI();
                }
                
                // Method 3: Force scroll to hide address bar (works on many browsers)
                setTimeout(() => {
                    window.scrollTo(0, 1);
                    // Scroll back to top after hiding address bar
                    setTimeout(() => {
                        window.scrollTo(0, 0);
                    }, 100);
                }, 50);
            }
            
            hideIOSBrowserUI() {
                // iOS Safari specific techniques
                console.log("Applying iOS-specific fullscreen techniques");
                
                // Try to use the minimal-ui viewport setting
                let viewport = document.querySelector('meta[name=viewport]');
                if (viewport) {
                    viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, minimal-ui, standalone=yes');
                }
                
                // iOS Safari: scroll to hide the address bar
                window.scrollTo(0, 1);
                
                // Force the page to think it's in standalone mode
                if (!window.navigator.standalone) {
                    // Add meta tag to simulate standalone mode
                    const meta = document.createElement('meta');
                    meta.name = 'apple-mobile-web-app-capable';
                    meta.content = 'yes';
                    document.head.appendChild(meta);
                }
            }
            
            hideAndroidBrowserUI() {
                // Android Chrome specific techniques
                console.log("Applying Android-specific fullscreen techniques");
                
                // Android Chrome supports fullscreen API better
                const element = document.documentElement;
                if (element.requestFullscreen) {
                    element.requestFullscreen().catch(() => {
                        console.log("Android fullscreen request failed, using fallback");
                        this.androidFallbackFullscreen();
                    });
                } else if (element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen().catch(() => {
                        console.log("Android webkit fullscreen request failed, using fallback");
                        this.androidFallbackFullscreen();
                    });
                } else {
                    this.androidFallbackFullscreen();
                }
            }
            
            androidFallbackFullscreen() {
                // Fallback for Android when fullscreen API fails
                window.scrollTo(0, 1);
                
                // Try to hide the address bar by manipulating the viewport
                let viewport = document.querySelector('meta[name=viewport]');
                if (viewport) {
                    viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, minimal-ui');
                }
            }
            
            hideGenericMobileBrowserUI() {
                // Generic mobile browser techniques
                console.log("Applying generic mobile fullscreen techniques");
                
                // Try standard fullscreen API
                const element = document.documentElement;
                if (element.requestFullscreen) {
                    element.requestFullscreen().catch(() => {
                        console.log("Generic fullscreen request failed");
                    });
                } else if (element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen().catch(() => {
                        console.log("Generic webkit fullscreen request failed");
                    });
                }
                
                // Scroll technique
                window.scrollTo(0, 1);
            }
            
            setupMobileResizeListener() {
                // Listen for viewport changes on mobile (when browser UI shows/hides)
                if (this.mobileResizeListener) {
                    window.removeEventListener('resize', this.mobileResizeListener);
                }
                
                this.mobileResizeListener = () => {
                    if (this.isFullscreen && this.isMobileDevice()) {
                        // Update viewport height when mobile browser UI changes
                        const vh = window.innerHeight * 0.01;
                        document.documentElement.style.setProperty('--vh', `${vh}px`);
                        
                        // Trigger canvas resize
                        this.onWindowResize();
                        
                        // Try to hide browser UI again if it appeared
                        setTimeout(() => {
                            this.hideMobileBrowserUI();
                        }, 100);
                    }
                };
                
                window.addEventListener('resize', this.mobileResizeListener);
                window.addEventListener('orientationchange', this.mobileResizeListener);
            }
            
            exitMobileFullscreen() {
                const body = document.body;
                const container = document.querySelector('.container');
                
                // Remove mobile fullscreen classes
                body.classList.remove('mobile-fullscreen');
                container.classList.remove('mobile-fullscreen');
                
                // Restore normal viewport
                let viewport = document.querySelector('meta[name=viewport]');
                if (viewport) {
                    viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover');
                }
                
                // Clean up mobile resize listener
                if (this.mobileResizeListener) {
                    window.removeEventListener('resize', this.mobileResizeListener);
                    window.removeEventListener('orientationchange', this.mobileResizeListener);
                    this.mobileResizeListener = null;
                }
                
                // Restore normal height and overflow settings
                document.documentElement.style.height = '';
                body.style.height = '';
                body.style.overflow = '';
                document.documentElement.style.overflow = '';
                
                // Reset viewport height custom property
                document.documentElement.style.removeProperty('--vh');
                
                // Exit native fullscreen if it was activated
                if (document.fullscreenElement || document.webkitFullscreenElement) {
                    if (document.exitFullscreen) {
                        document.exitFullscreen().catch(() => {
                            console.log("Could not exit native fullscreen");
                        });
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen().catch(() => {
                            console.log("Could not exit webkit fullscreen");
                        });
                    }
                }
                
                this.isFullscreen = false;
                this.updateFullscreenButton();
                
                // Trigger resize after a short delay
                setTimeout(() => {
                    this.onWindowResize();
                }, 100);
                
                console.log("Exited mobile fullscreen mode");
            }
            
            setupFullscreenListeners() {
                const fullscreenChangeHandler = () => {
                    const isFullscreen = !!(document.fullscreenElement || 
                                           document.mozFullScreenElement || 
                                           document.webkitFullscreenElement || 
                                           document.msFullscreenElement);
                    
                    this.isFullscreen = isFullscreen;
                    this.updateFullscreenButton();
                    this.onWindowResize(); // Trigger resize when fullscreen state changes
                    
                    console.log(isFullscreen ? "Entered fullscreen" : "Exited fullscreen");
                };
                
                // Add event listeners for fullscreen change
                document.addEventListener('fullscreenchange', fullscreenChangeHandler);
                document.addEventListener('mozfullscreenchange', fullscreenChangeHandler);
                document.addEventListener('webkitfullscreenchange', fullscreenChangeHandler);
                document.addEventListener('MSFullscreenChange', fullscreenChangeHandler);
            }
            
            updateFullscreenButton() {
                const toggleButton = document.getElementById('toggle-fullscreen');
                
                if (toggleButton) {
                    if (this.isFullscreen) {
                        toggleButton.textContent = '⛶'; // Exit fullscreen icon
                        toggleButton.classList.add('active');
                        if (this.isMobileDevice()) {
                            toggleButton.title = 'Exit Immersive Mode';
                        } else {
                            toggleButton.title = 'Exit Fullscreen';
                        }
                    } else {
                        toggleButton.textContent = '⛶'; // Enter fullscreen icon
                        toggleButton.classList.remove('active');
                        if (this.isMobileDevice()) {
                            toggleButton.title = 'Enter Immersive Mode';
                        } else {
                            toggleButton.title = 'Enter Fullscreen';
                        }
                    }
                }
            }
            
            isMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform));
            }
            
            isIOSDevice() {
                return /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                       (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            }
            
            isAndroidDevice() {
                return /Android/i.test(navigator.userAgent);
            }
            

            
            playTargetingSound() {
                if (!this.soundEnabled) return;
                
                // Check if hover sounds are globally disabled
                if (!this.audioConfig?.hover_sounds_enabled) {
                    return;
                }
                
                // Implement cooldown to prevent audio spam during fast hovering
                const now = Date.now();
                if (now - this.lastHoverSoundTime < this.hoverSoundCooldown) {
                    return;
                }
                this.lastHoverSoundTime = now;
                
                // Try to play audio file first using the pool system
                if (this.audioFiles.hover && this.audioFiles.hover.getNext) {
                    try {
                        // Get next available audio instance from pool
                        const audio = this.audioFiles.hover.getNext();
                        
                        // Reset to beginning if needed (should be fast since it's pre-loaded)
                        if (audio.currentTime > 0) {
                            audio.currentTime = 0;
                        }
                        
                        // Play immediately - no await to avoid delay
                        audio.play().catch(error => {
                            console.warn("Error playing hover audio file:", error);
                            this.playGeneratedTargetingSound();
                        });
                        return;
                    } catch (error) {
                        console.warn("Error with hover audio file:", error);
                    }
                }
                
                // Fallback to generated sound
                if (this.audioConfig?.fallback_to_generated) {
                    this.playGeneratedTargetingSound();
                }
            }
            
            playGeneratedTargetingSound() {
                if (!this.audioEnabled || !this.audioContext) return;
                
                try {
                    // Create a Star Wars blaster pistol sound
                    const noiseBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.15, this.audioContext.sampleRate);
                    const noiseData = noiseBuffer.getChannelData(0);
                    
                    // Generate white noise for the base
                    for (let i = 0; i < noiseData.length; i++) {
                        noiseData[i] = Math.random() * 2 - 1;
                    }
                    
                    const noiseSource = this.audioContext.createBufferSource();
                    noiseSource.buffer = noiseBuffer;
                    
                    const gainNode = this.audioContext.createGain();
                    const filterNode = this.audioContext.createBiquadFilter();
                    const highpassFilter = this.audioContext.createBiquadFilter();
                    
                    // Connect: noise -> highpass -> lowpass -> gain -> destination
                    noiseSource.connect(highpassFilter);
                    highpassFilter.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    // Configure filters for blaster sound
                    highpassFilter.type = 'highpass';
                    highpassFilter.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(4000, this.audioContext.currentTime);
                    filterNode.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.12);
                    filterNode.Q.setValueAtTime(3, this.audioContext.currentTime);
                    
                    // Classic blaster envelope - sharp attack, quick decay
                    const volume = this.audioConfig?.volume || 0.3;
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(volume * 0.5, this.audioContext.currentTime + 0.003);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.12);
                    
                    // Play sound
                    noiseSource.start(this.audioContext.currentTime);
                    noiseSource.stop(this.audioContext.currentTime + 0.15);
                } catch (error) {
                    console.warn("Error playing generated targeting sound:", error);
                }
            }
            
            playSelectionSound() {
                if (!this.soundEnabled) return;
                
                // Check if click sounds are globally disabled
                if (!this.audioConfig?.click_sounds_enabled) {
                    return;
                }
                
                // Try to play audio file first
                if (this.audioFiles.click && this.audioFiles.click.getNext) {
                    try {
                        // Get next available audio instance from pool
                        const audio = this.audioFiles.click.getNext();
                        
                        // Reset to beginning if needed (should be fast since it's pre-loaded)
                        if (audio.currentTime > 0) {
                            audio.currentTime = 0;
                        }
                        
                        // Play immediately - no await to avoid delay
                        audio.play().catch(error => {
                            console.warn("Error playing click audio file:", error);
                            this.playGeneratedSelectionSound();
                        });
                        return;
                    } catch (error) {
                        console.warn("Error with click audio file:", error);
                    }
                }
                
                // Fallback to generated sound - use a quick click instead of the long whoosh
                if (this.audioConfig?.fallback_to_generated) {
                    this.playQuickClickSound();
                }
            }
            
            playQuickClickSound() {
                if (!this.audioEnabled || !this.audioContext) return;
                
                try {
                    // Create a quick, immediate click sound - much faster than the long whoosh
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filterNode = this.audioContext.createBiquadFilter();
                    
                    // Connect: oscillator -> filter -> gain -> destination
                    oscillator.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    // Configure for a sharp, quick click
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.05);
                    
                    // High-pass filter for crisp sound
                    filterNode.type = 'highpass';
                    filterNode.frequency.setValueAtTime(400, this.audioContext.currentTime);
                    
                    // Very quick envelope - immediate attack, fast decay
                    const volume = (this.audioConfig?.volume || 0.3) * 0.4; // Quieter than main sounds
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + 0.001); // Instant attack
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.08); // Quick decay
                    
                    // Play the quick click
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1); // Very short duration
                } catch (error) {
                    console.warn("Error playing quick click sound:", error);
                }
            }
            
            playGeneratedSelectionSound() {
                if (!this.audioEnabled || !this.audioContext) return;
                
                try {
                    // Create a massive planet rushing by at extreme speed - cinematic whoosh
                    
                    // Generate noise buffer for the whoosh base
                    const noiseBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 3.0, this.audioContext.sampleRate);
                    const noiseData = noiseBuffer.getChannelData(0);
                    
                    // Generate pink noise (more natural than white noise)
                    let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                    for (let i = 0; i < noiseData.length; i++) {
                        const white = Math.random() * 2 - 1;
                        b0 = 0.99886 * b0 + white * 0.0555179;
                        b1 = 0.99332 * b1 + white * 0.0750759;
                        b2 = 0.96900 * b2 + white * 0.1538520;
                        b3 = 0.86650 * b3 + white * 0.3104856;
                        b4 = 0.55000 * b4 + white * 0.5329522;
                        b5 = -0.7616 * b5 - white * 0.0168980;
                        noiseData[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                        b6 = white * 0.115926;
                    }
                    
                    const noiseSource = this.audioContext.createBufferSource();
                    noiseSource.buffer = noiseBuffer;
                    
                    // Create multiple processing chains for layered effect
                    const mainGain = this.audioContext.createGain();
                    const lowFilter = this.audioContext.createBiquadFilter();
                    const midFilter = this.audioContext.createBiquadFilter();
                    const highFilter = this.audioContext.createBiquadFilter();
                    const dopplerGain = this.audioContext.createGain();
                    
                    // Add deep rumble oscillator for planetary mass
                    const rumbleOsc = this.audioContext.createOscillator();
                    const rumbleGain = this.audioContext.createGain();
                    
                    // Connect noise through multiple filters for rich spectrum
                    noiseSource.connect(lowFilter);
                    noiseSource.connect(midFilter);
                    noiseSource.connect(highFilter);
                    
                    lowFilter.connect(mainGain);
                    midFilter.connect(mainGain);
                    highFilter.connect(dopplerGain);
                    dopplerGain.connect(mainGain);
                    
                    // Connect rumble
                    rumbleOsc.connect(rumbleGain);
                    rumbleGain.connect(mainGain);
                    
                    mainGain.connect(this.audioContext.destination);
                    
                    // Configure filters for different frequency bands
                    lowFilter.type = 'lowpass';
                    lowFilter.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    lowFilter.Q.setValueAtTime(0.5, this.audioContext.currentTime);
                    
                    midFilter.type = 'bandpass';
                    midFilter.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    midFilter.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 3.0);
                    midFilter.Q.setValueAtTime(2, this.audioContext.currentTime);
                    
                    // High frequencies for the whoosh - simulate Doppler effect
                    highFilter.type = 'highpass';
                    highFilter.frequency.setValueAtTime(1500, this.audioContext.currentTime);
                    highFilter.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 1.5);
                    highFilter.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 3.0);
                    
                    // Deep rumble for planetary mass
                    rumbleOsc.frequency.setValueAtTime(30, this.audioContext.currentTime);
                    rumbleOsc.frequency.exponentialRampToValueAtTime(20, this.audioContext.currentTime + 1.5);
                    rumbleOsc.frequency.exponentialRampToValueAtTime(15, this.audioContext.currentTime + 3.0);
                    
                    // Doppler effect simulation - approaching then receding
                    dopplerGain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    dopplerGain.gain.exponentialRampToValueAtTime(1.2, this.audioContext.currentTime + 0.8); // Approaching
                    dopplerGain.gain.exponentialRampToValueAtTime(0.1, this.audioContext.currentTime + 3.0); // Receding
                    
                    // Rumble envelope
                    rumbleGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                    rumbleGain.gain.linearRampToValueAtTime(0.4, this.audioContext.currentTime + 0.3);
                    rumbleGain.gain.exponentialRampToValueAtTime(0.2, this.audioContext.currentTime + 1.5);
                    rumbleGain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 3.0);
                    
                    // Main envelope - massive object passing by
                    const volume = this.audioConfig?.volume || 0.3;
                    mainGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                    mainGain.gain.linearRampToValueAtTime(volume * 0.3, this.audioContext.currentTime + 0.2); // Distant approach
                    mainGain.gain.exponentialRampToValueAtTime(volume * 0.8, this.audioContext.currentTime + 1.0); // Getting closer
                    mainGain.gain.exponentialRampToValueAtTime(volume, this.audioContext.currentTime + 1.5); // Closest point
                    mainGain.gain.exponentialRampToValueAtTime(volume * 0.5, this.audioContext.currentTime + 2.2); // Moving away
                    mainGain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 3.0); // Distant
                    
                    // Start all sources
                    noiseSource.start(this.audioContext.currentTime);
                    rumbleOsc.start(this.audioContext.currentTime);
                    
                    noiseSource.stop(this.audioContext.currentTime + 3.0);
                    rumbleOsc.stop(this.audioContext.currentTime + 3.0);
                } catch (error) {
                    console.warn("Error playing generated selection sound:", error);
                }
            }
            
            createSphericalContainer() {
                // Define the maximum radius based on the number of levels
                const maxRadius = this.calculateMaxSphereRadius();
                
                // Store the sphere radius for positioning calculations but don't render it
                // This maintains the structural layout without visual interference
                this.sphereRadius = maxRadius;
                
                // Create a wireframe sphere but don't add it to the scene to avoid rendering conflicts
                // We keep the geometry for potential future use but it won't interfere with links
                const sphereGeometry = new THREE.SphereGeometry(maxRadius, 64, 32);
                const wireframe = new THREE.WireframeGeometry(sphereGeometry);
                
                // Store the sphere data without adding to scene
                this.sphereGeometry = sphereGeometry;
                this.sphereWireframe = wireframe;
                
                console.log("Spherical container created (structure only, no rendering)");
            }
            
            calculateMaxSphereRadius() {
                // This will be updated when data is loaded
                // Default initial radius
                return 500;
            }
            
            setupEventListeners() {
                console.log("Setting up event listeners");
                
                // Control buttons
                const zoomInButton = document.getElementById('zoom-in');
                const zoomOutButton = document.getElementById('zoom-out');
                const resetViewButton = document.getElementById('reset-view');
                const toggleRotationButton = document.getElementById('toggle-rotation');
                const expandAllButton = document.getElementById('expand-all');
                const collapseAllButton = document.getElementById('collapse-all');
                const toggleSoundButton = document.getElementById('toggle-sound');
                const toggleFullscreenButton = document.getElementById('toggle-fullscreen');
                // Details panel expand-all button variable removed
                const backButton = document.getElementById('back-button');
                
                if (zoomInButton) {
                    zoomInButton.addEventListener('click', () => {
                        this.zoomIn();
                        this.cameraControlsNeedUpdate = true;
                    });
                }
                
                if (zoomOutButton) {
                    zoomOutButton.addEventListener('click', () => {
                        this.zoomOut();
                        this.cameraControlsNeedUpdate = true;
                    });
                }
                
                if (resetViewButton) {
                    resetViewButton.addEventListener('click', () => {
                        this.resetView();
                        this.cameraControlsNeedUpdate = true;
                    });
                }
                
                if (toggleRotationButton) {
                    toggleRotationButton.addEventListener('click', () => {
                        this.toggleRotation();
                    });
                }
                
                // Add expand-all button event listener
                if (expandAllButton) {
                    expandAllButton.addEventListener('click', () => {
                        this.expandAllNodes();
                    });
                }
                
                // Add collapse-all button event listener
                if (collapseAllButton) {
                    collapseAllButton.addEventListener('click', () => {
                        this.collapseAllNodes();
                    });
                }
                
                // Add sound toggle button event listener
                if (toggleSoundButton) {
                    toggleSoundButton.addEventListener('click', () => {
                        this.toggleSound();
                    });
                }
                
                // Add fullscreen toggle button event listener
                if (toggleFullscreenButton) {
                    toggleFullscreenButton.addEventListener('click', () => {
                        this.toggleFullscreen();
                    });
                }
                
                // Details panel expand-all button removed
                
                // Add back button event listener
                if (backButton) {
                    backButton.addEventListener('click', () => {
                        this.navigateBack();
                    });
                }
                
                // Add toggle panel button event listener
                const togglePanelButton = document.getElementById('toggle-panel');
                if (togglePanelButton) {
                    togglePanelButton.addEventListener('click', () => {
                        this.toggleDetailsPanel();
                    });
                }
                
                // Add toggle legend button event listener
                const toggleLegendButton = document.getElementById('toggle-legend');
                if (toggleLegendButton) {
                    toggleLegendButton.addEventListener('click', () => {
                        this.toggleLegend();
                    });
                }
                
                // Add toggle help button event listener
                const toggleHelpButton = document.getElementById('toggle-help');
                if (toggleHelpButton) {
                    toggleHelpButton.addEventListener('click', () => {
                        this.toggleHelp();
                    });
                }
                
                // OrbitControls events
                if (this.controls) {
                    this.controls.addEventListener('change', () => {
                        this.cameraControlsNeedUpdate = true;
                    });
                }
                
                // Mouse move event for hover
                this.container.addEventListener('mousemove', this.onMouseMove.bind(this));
                
                // Click event
                this.container.addEventListener('click', this.onClick.bind(this));
                
                // Add user interaction listeners for background music
                const startMusicOnInteraction = () => {
                    this.ensureBackgroundMusicStarted();
                };
                
                // Listen for various user interactions - comprehensive coverage
                document.addEventListener('click', startMusicOnInteraction);
                document.addEventListener('keydown', startMusicOnInteraction);
                document.addEventListener('touchstart', startMusicOnInteraction);
                document.addEventListener('mousedown', startMusicOnInteraction);
                this.container.addEventListener('mouseenter', startMusicOnInteraction);
                
                // Also trigger on button clicks specifically
                const buttons = document.querySelectorAll('button');
                buttons.forEach(button => {
                    button.addEventListener('click', startMusicOnInteraction);
                });
                

                
                // Resize event
                window.addEventListener('resize', this.onWindowResize.bind(this));
                
                // Initialize the flag
                this.cameraControlsNeedUpdate = true;
            }
            
            // Get nodes that should be visible based on expanded state
            getVisibleNodes() {
                try {
                    if (!this.graphData || !this.graphData.nodes || !Array.isArray(this.graphData.nodes)) {
                        console.error("Invalid graph data in getVisibleNodes");
                        return [];
                    }
                    
                    const visibleNodes = [];
                    
                    // Find root node(s) - these have no parent or level 0
                    const rootNodes = this.graphData.nodes.filter(node => 
                        !node.parent || (node.level !== undefined && node.level === 0)
                    );
                    
                    if (rootNodes.length === 0) {
                        console.warn("No root nodes found - using first node as fallback");
                        if (this.graphData.nodes.length > 0) {
                            const firstNode = this.graphData.nodes[0];
                            firstNode.level = firstNode.level || 0; // Ensure level is set
                            visibleNodes.push(firstNode);
                        }
                        return visibleNodes;
                    }
                    
                    // Start with root nodes
                    rootNodes.forEach(rootNode => {
                        rootNode.level = rootNode.level || 0; // Ensure level is set
                        visibleNodes.push(rootNode);
                        
                        // If root is expanded, add its children
                        if (this.expandedNodes.has(rootNode.id)) {
                            this.addVisibleChildren(rootNode.id, visibleNodes);
                        }
                    });
                    
                    return visibleNodes;
                } catch (error) {
                    console.error("Error in getVisibleNodes:", error);
                    return [];
                }
            }
            
            // Add visible children recursively
            addVisibleChildren(parentId, visibleNodes) {
                try {
                    if (!this.graphData || !this.graphData.nodes) {
                        return;
                    }
                    
                    // Find all direct children of this parent
                    const children = this.graphData.nodes.filter(node => 
                        node.parent === parentId
                    );
                    
                    // Add each child and potentially its children
                    children.forEach(child => {
                        // Skip if already added (prevents duplicates)
                        if (visibleNodes.some(node => node.id === child.id)) {
                            return;
                        }
                        
                        // Ensure level is properly set
                        if (child.level === undefined) {
                            const parentNode = this.graphData.nodes.find(n => n.id === parentId);
                            child.level = (parentNode?.level !== undefined) ? parentNode.level + 1 : 1;
                        }
                        
                        // Add this child
                        visibleNodes.push(child);
                        
                        // If this child is expanded, add its children too
                        if (this.expandedNodes.has(child.id)) {
                            this.addVisibleChildren(child.id, visibleNodes);
                        }
                    });
                } catch (error) {
                    console.error("Error in addVisibleChildren:", error);
                }
            }
            
            onMouseMove(event) {
                // Start background music on first mouse movement (earlier than click)
                if (!this.hasUserInteracted) {
                    this.ensureBackgroundMusicStarted();
                }
                
                // Get the scene container bounds for accurate mouse position calculation
                const rect = this.container.getBoundingClientRect();
                
                // Calculate mouse position in normalized device coordinates (-1 to +1)
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                // Update the picking ray with the camera and mouse position
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                // Find all intersected objects
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                
                // Check if we're hovering over a node
                if (intersects.length > 0) {
                    // Find the first intersected node (not a line)
                    const intersectedNode = intersects.find(intersect => 
                        intersect.object.userData && 
                        intersect.object.userData.nodeId &&
                        intersect.object.type === 'Mesh'
                    );
                    
                    if (intersectedNode) {
                        const nodeId = intersectedNode.object.userData.nodeId;
                        const nodeData = this.graphData.nodes.find(n => n.id === nodeId);
                        
                        if (nodeData) {
                            // Play targeting sound if not already targeting this node
                            if (this.currentTargetNode !== nodeId) {
                                this.playTargetingSound();
                                this.currentTargetNode = nodeId;
                            }
                            
                            // Show hover display
                            this.hoverDisplay.innerHTML = `
                                <div class="node-type">${this.capitalizeFirstLetter(nodeData.type.replace('_', ' '))}</div>
                                <div class="node-name">${nodeData.name}</div>
                            `;
                            this.hoverDisplay.style.display = 'block';
                            this.hoverDisplay.style.opacity = '1';
                            
                            // Position hover display at mouse position
                            const x = event.clientX;
                            const y = event.clientY - 40; // Offset above the cursor
                            
                            this.hoverDisplay.style.left = `${x}px`;
                            this.hoverDisplay.style.top = `${y}px`;
                            this.hoverDisplay.style.transform = 'translate(-50%, -100%)';
                            
                            // Set cursor to pointer
                            this.container.style.cursor = 'pointer';
                            return;
                        }
                    }
                }
                
                // If not hovering over a node, reset states
                this.currentTargetNode = null;
                this.hoverDisplay.style.opacity = '0';
                this.hoverDisplay.style.display = 'none';
                this.container.style.cursor = 'default';
            }
            

            
            capitalizeFirstLetter(string) {
                if (!string) return '';
                return string.split(' ').map(word => {
                    return word.charAt(0).toUpperCase() + word.slice(1);
                }).join(' ');
            }
            
            getNodeColor(nodeType) {
                // Return colors based on node type
                const colors = {
                    'component_group': '#4A90E2',
                    'component': '#50C878',
                    'subcomponent': '#9B59B6',
                    'capability': '#E67E22',
                    'function': '#E74C3C',
                    'specification': '#F1C40F',
                    'integration': '#16A085',
                    'technique': '#2ECC71',
                    'application': '#3498DB',
                    'input': '#5499C7',
                    'output': '#F39C12'
                };
                
                return colors[nodeType] || '#CCCCCC'; // Default gray for unknown types
            }
            
            getNodeSize(nodeType, level = 0) {
                // Calculate size based on node type and level
                // Root node should be largest, with decreasing sizes as we move outward
                // But each type should have a specific size relative to its importance
                
                // Base sizes for different node types (larger than before)
                const baseSizes = {
                    'component_group': 18,
                    'component': 15,
                    'subcomponent': 12,
                    'capability': 10,
                    'function': 9,
                    'specification': 9,
                    'integration': 8,
                    'technique': 8,
                    'application': 8,
                    'input': 6,
                    'output': 7
                };
                
                // Get base size or default to 6
                const baseSize = baseSizes[nodeType] || 6;
                
                // Calculate level adjustment factor - higher levels get smaller
                const levelFactor = Math.max(0.6, 1 - (level * 0.05));
                
                // Apply level factor to base size
                return baseSize * levelFactor;
            }
            
            onClick(event) {
                // Check if the click was on a UI element (button, control, etc.)
                // If so, don't process it as a visualization click
                if (event.target.tagName === 'BUTTON' || 
                    event.target.closest('button') || 
                    event.target.closest('.controls') ||
                    event.target.closest('.panel-toggle') ||
                    event.target.closest('.legend')) {
                    return;
                }
                
                // Get the scene container bounds for accurate mouse position calculation
                const rect = this.container.getBoundingClientRect();
                
                // Calculate mouse position in normalized device coordinates (-1 to +1)
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                // Update the picking ray with the camera and mouse position
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                // Find all intersected objects
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                
                // Check if we clicked on a node
                if (intersects.length > 0) {
                    // Find the first intersected node (not a line)
                    const intersectedNode = intersects.find(intersect => 
                        intersect.object.userData && 
                        intersect.object.userData.nodeId &&
                        intersect.object.type === 'Mesh'
                    );
                    
                    if (intersectedNode) {
                        const nodeId = intersectedNode.object.userData.nodeId;
                        const nodeData = this.graphData.nodes.find(n => n.id === nodeId);
                        
                        if (nodeData) {
                            console.log(`Clicked on node: ${nodeData.name} (${nodeData.id})`);
                            
                            // Start background music on first user interaction (if not already playing)
                            this.ensureBackgroundMusicStarted();
                            
                            // Play selection sound
                            this.playSelectionSound();
                            
                            // If the node has children, toggle expansion
                            if (nodeData.has_children) {
                                // Prevent rapid successive operations that could cause orphaned objects
                                if (this._processingExpansion) {
                                    console.log("Already processing expansion/collapse, ignoring click");
                                    return;
                                }
                                
                                this._processingExpansion = true;
                                
                                try {
                                    if (this.expandedNodes.has(nodeId)) {
                                        // Node is expanded, collapse it and all its descendants
                                        console.log(`Collapsing node ${nodeId} and all its descendants`);
                                        
                                        // Remove this node from expanded set
                                        this.expandedNodes.delete(nodeId);
                                        
                                        // Remove all descendants from expanded set
                                        const allDescendants = this.findAllDescendants(nodeId);
                                        allDescendants.forEach(descendantId => {
                                            this.expandedNodes.delete(descendantId);
                                        });
                                        
                                        // Check if this is root node collapse (same as "Collapse All")
                                        const nodeData = this.graphData.nodes.find(n => n.id === nodeId);
                                        const isRootCollapse = nodeData && nodeData.level === 0;
                                        
                                        if (isRootCollapse) {
                                            // Root node collapse = same as "Collapse All" - use comprehensive cleanup
                                            console.log("Root node collapse detected - using comprehensive cleanup");
                                            this.clearAllVisualElements();
                                            
                                            // Rebuild visualization with only root expanded
                                            const visibleNodes = this.getVisibleNodes();
                                            this.positionNodes(visibleNodes);
                                            this.createNodeObjects(visibleNodes);
                                            this.createLinkObjects(this.getVisibleLinks(visibleNodes));
                                            this.setupNodeAnimations(visibleNodes);
                                        } else {
                                            // Regular node collapse - use fast selective removal
                                            this.selectivelyRemoveDescendants(nodeId);
                                            
                                            // Fast update without repositioning existing nodes
                                            const visibleNodes = this.getVisibleNodes();
                                            this.fastUpdateVisualization(visibleNodes);
                                        }
                                        
                                        console.log(`Collapsed to ${this.getVisibleNodes().length} visible nodes`);
                                    } else {
                                        // Node is collapsed, expand it
                                        this.expandedNodes.add(nodeId);
                                        
                                        // Update the visualization
                                        const visibleNodes = this.getVisibleNodes();
                                        this.positionNodes(visibleNodes);
                                        this.createNodeObjects(visibleNodes);
                                        this.createLinkObjects(this.getVisibleLinks(visibleNodes));
                                        
                                        // Update animations for newly visible nodes
                                        this.setupNodeAnimations(visibleNodes);
                                    }
                                } finally {
                                    // Clear the processing flag after a short delay (longer for comprehensive cleanup)
                                    setTimeout(() => {
                                        this._processingExpansion = false;
                                    }, 300);
                                }
                            }
                            
                            // Select the node to show details
                            this.selectNode(nodeData);
                            
                            // Mark camera controls for update
                            this.cameraControlsNeedUpdate = true;
                        }
                        return; // Exit early since we clicked on a node
                    }
                }
                
                // If we reach here, we clicked on empty space (no node was clicked)
                // Check for double-click
                const currentTime = Date.now();
                const timeDiff = currentTime - this.lastClickTime;
                
                if (timeDiff < this.doubleClickThreshold) {
                    // This is a double-click on empty space
                    console.log("Double-clicked on empty space - deselecting current node");
                    
                    // Start background music on first user interaction (if not already playing)
                    this.ensureBackgroundMusicStarted();
                    
                    // Deselect the current node
                    this.deselectNode();
                    
                    // Reset the timer to prevent triple-click issues
                    this.lastClickTime = 0;
                } else {
                    // Single click on empty space - just update the timer
                    console.log("Single click on empty space - ignoring (double-click required to deselect)");
                    this.lastClickTime = currentTime;
                }
            }
            
            recursivelyCollapseChildren(nodeId) {
                console.log(`Collapsing children of node: ${nodeId}`);
                
                // Get all nodes that have this node as a parent
                const children = this.graphData.nodes.filter(n => n.parent === nodeId);
                
                // For each child
                children.forEach(child => {
                    // Remove from expanded nodes set
                    this.expandedNodes.delete(child.id);
                    console.log(`Collapsed node: ${child.id}`);
                    
                    // Recursively collapse its children
                    this.recursivelyCollapseChildren(child.id);
                });
                
                // Safety check to ensure all descendants are truly collapsed
                // This handles cases where the parent-child relationships might not be perfect
                const allDescendants = this.findAllDescendants(nodeId);
                allDescendants.forEach(descendantId => {
                    if (this.expandedNodes.has(descendantId)) {
                        console.log(`Force collapsing descendant: ${descendantId}`);
                        this.expandedNodes.delete(descendantId);
                    }
                });
            }
            
            // Helper method to find all descendants of a node regardless of direct parent links
            findAllDescendants(nodeId) {
                const descendants = new Set();
                
                // Helper function to recursively collect descendants
                const collectDescendants = (id) => {
                    // Find direct children
                    const children = this.graphData.nodes.filter(n => n.parent === id);
                    
                    // Add each child and its descendants
                    children.forEach(child => {
                        descendants.add(child.id);
                        collectDescendants(child.id);
                    });
                };
                
                // Start the recursive collection
                collectDescendants(nodeId);
                
                return Array.from(descendants);
            }
            
            cullNodesOutsideViewport() {
                // Skip if not using optimization
                if (!this.frustumCulled) return;
                
                // Get the camera frustum
                const frustum = new THREE.Frustum();
                const matrix = new THREE.Matrix4().multiplyMatrices(
                    this.camera.projectionMatrix,
                    this.camera.matrixWorldInverse
                );
                frustum.setFromProjectionMatrix(matrix);
                
                // Check each node against the frustum
                this.nodes.forEach((nodeMesh, nodeId) => {
                    if (nodeMesh.isInstancedNode) {
                        // For instanced nodes, we need to update their visibility differently
                        const instancedMesh = nodeMesh.userData.instancedMesh;
                        const instanceIndex = nodeMesh.userData.instanceIndex;
                        
                        // Skip if already processed this instanced mesh
                        if (instancedMesh.userData.frustumChecked) return;
                        
                        // Mark as processed
                        instancedMesh.userData.frustumChecked = true;
                        
                        // Check the whole instanced mesh bounding box
                        instancedMesh.geometry.computeBoundingBox();
                        const boundingBox = instancedMesh.geometry.boundingBox.clone();
                        boundingBox.applyMatrix4(instancedMesh.matrixWorld);
                        
                        // Set visibility based on whether it's in the frustum
                        instancedMesh.visible = frustum.intersectsBox(boundingBox);
                    } else {
                        // For individual meshes, just check position
                        const position = nodeMesh.position.clone();
                        nodeMesh.visible = frustum.containsPoint(position);
                    }
                });
                
                // Reset the frustum checked flag for next frame
                this.nodes.forEach(nodeMesh => {
                    if (nodeMesh.isInstancedNode && nodeMesh.userData.instancedMesh) {
                        nodeMesh.userData.instancedMesh.userData.frustumChecked = false;
                    }
                });
            }
            
            getVisibleLinks(visibleNodes) {
                // If no graph data or visibleNodes not provided, return empty array
                if (!this.graphData || !this.graphData.links || !visibleNodes) {
                    return [];
                }
                
                // Create a set of visible node IDs for faster lookup
                const nodeIds = new Set(visibleNodes.map(node => node.id));
                
                // Filter links where both source and target are visible
                return this.graphData.links.filter(link => {
                    const source = typeof link.source === 'object' ? link.source.id : link.source;
                    const target = typeof link.target === 'object' ? link.target.id : link.target;
                    return nodeIds.has(source) && nodeIds.has(target);
                });
            }
            
            positionNodes(nodes) {
                // Position the root node at the center
                const rootNode = nodes.find(node => node.level === 0);
                if (rootNode) {
                    this.nodePositions.set(rootNode.id, { x: 0, y: 0, z: 0 });
                }

                // Group nodes by level for better organization
                const nodesByLevel = new Map();
                const maxLevel = Math.max(...nodes.map(n => n.level));
                
                // Calculate the maximum radius for our bounding sphere
                const sphereRadius = 400 + (maxLevel * 50);
                
                // Update sphere radius for positioning calculations (no rendering)
                this.sphereRadius = sphereRadius;
                
                // Update stored geometry if needed (but don't render)
                if (this.sphereGeometry) {
                    this.sphereGeometry.dispose();
                }
                if (this.sphereWireframe) {
                    this.sphereWireframe.dispose();
                }
                
                // Create new geometry for structural calculations
                this.sphereGeometry = new THREE.SphereGeometry(sphereRadius, 64, 32);
                this.sphereWireframe = new THREE.WireframeGeometry(this.sphereGeometry);
                
                // Group nodes by level
                nodes.forEach(node => {
                    if (!nodesByLevel.has(node.level)) {
                        nodesByLevel.set(node.level, []);
                    }
                    nodesByLevel.get(node.level).push(node);
                });

                // Place nodes by level and organizational hierarchy
                for (let level = 1; level <= maxLevel; level++) {
                    const levelNodes = nodesByLevel.get(level) || [];
                    if (levelNodes.length === 0) continue;
                    
                    // Group nodes by their parent
                    const nodesByParent = new Map();
                    levelNodes.forEach(node => {
                        if (!node.parent) return;
                        
                        if (!nodesByParent.has(node.parent)) {
                            nodesByParent.set(node.parent, []);
                        }
                        nodesByParent.get(node.parent).push(node);
                    });
                    
                    // Calculate level radius based on hyperbolic scaling
                    // As level increases, radius approaches the sphere boundary but never reaches it
                    const levelProgress = level / (maxLevel + 1); // +1 to ensure we don't reach 1.0
                    const levelRadius = sphereRadius * (1 - Math.pow(1 - levelProgress, 2));
                    
                    // Position each parent's children in 3D spherical distribution
                    nodesByParent.forEach((children, parentId) => {
                        const parentPos = this.nodePositions.get(parentId) || { x: 0, y: 0, z: 0 };
                        const childCount = children.length;
                        
                        // If only one child, place it directly out from parent
                        if (childCount === 1) {
                            const direction = new THREE.Vector3(
                                Math.random() - 0.5,
                                Math.random() - 0.5,
                                Math.random() - 0.5
                            ).normalize();
                            
                            const distance = levelRadius - Math.sqrt(parentPos.x * parentPos.x + parentPos.y * parentPos.y + parentPos.z * parentPos.z);
                            
                            this.nodePositions.set(children[0].id, {
                                x: parentPos.x + direction.x * distance,
                                y: parentPos.y + direction.y * distance,
                                z: parentPos.z + direction.z * distance
                            });
                            return;
                        }
                        
                        // For multiple children, distribute using Fibonacci spiral on sphere section
                        const parentToCenter = Math.sqrt(parentPos.x * parentPos.x + parentPos.y * parentPos.y + parentPos.z * parentPos.z);
                        const parentDirection = parentToCenter === 0 ? 
                            new THREE.Vector3(0, 1, 0) : 
                            new THREE.Vector3(parentPos.x / parentToCenter, parentPos.y / parentToCenter, parentPos.z / parentToCenter);
                        
                        // Create a basis for distributing points around parent direction
                        const upVector = Math.abs(parentDirection.y) > 0.9 ? 
                            new THREE.Vector3(1, 0, 0) : 
                            new THREE.Vector3(0, 1, 0);
                        
                        const rightVector = new THREE.Vector3().crossVectors(parentDirection, upVector).normalize();
                        const actualUpVector = new THREE.Vector3().crossVectors(rightVector, parentDirection).normalize();
                        
                        // Angle to spread children (narrower for deeper levels)
                        const spreadAngle = Math.PI / 2 * Math.pow(0.8, level - 1);
                        
                        // Position each child using spherical coordinates relative to parent direction
                        children.forEach((node, i) => {
                            // Fibonacci spiral distribution for even spacing on partial sphere
                            const phi = Math.acos(1 - 2 * (i + 0.5) / childCount);
                            const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
                            
                            // Convert to cartesian but limit to spread angle
                            const x = Math.sin(phi * spreadAngle) * Math.cos(theta);
                            const y = Math.sin(phi * spreadAngle) * Math.sin(theta);
                            const z = Math.cos(phi * spreadAngle);
                            
                            // Transform to parent-oriented basis
                            const localPos = new THREE.Vector3(
                                x * rightVector.x + y * actualUpVector.x + z * parentDirection.x,
                                x * rightVector.y + y * actualUpVector.y + z * parentDirection.y,
                                x * rightVector.z + y * actualUpVector.z + z * parentDirection.z
                            );
                            
                            // Calculate distance from center to maintain level radius
                            const distToParent = levelRadius - parentToCenter;
                            
                            // Get node sizes to ensure initial spacing
                            const parentSize = this.getNodeSize(nodesByLevel.get(level - 1)?.find(n => n.id === parentId)?.type || 'component', level - 1);
                            const childSize = this.getNodeSize(node.type, node.level);
                            const minSpacing = parentSize + childSize + 10; // Add some initial spacing
                            
                            // Ensure minimum distance from parent
                            const actualDist = Math.max(distToParent * 0.3, minSpacing); // Use at least 30% of calculated distance or minimum spacing
                            
                            // Set position
                            this.nodePositions.set(node.id, {
                                x: parentPos.x + localPos.x * actualDist,
                                y: parentPos.y + localPos.y * actualDist,
                                z: parentPos.z + localPos.z * actualDist
                            });
                        });
                    });
                }

                // Apply spacing to reduce node overlap but preserve the overall structure
                this.applyHyperbolicSpacing(nodes, sphereRadius);
            }
            
            applyHyperbolicSpacing(nodes, sphereRadius) {
                const baseSpacing = 15; // Increased base spacing between node surfaces
                const iterations = 8;   // More iterations for better convergence
                
                // Cache parent-child relationships for quick lookup
                const childrenByParent = new Map();
                const parentByChild = new Map();
                
                // Cache node sizes for performance
                const nodeSizes = new Map();
                nodes.forEach(node => {
                    const size = this.getNodeSize(node.type, node.level);
                    nodeSizes.set(node.id, size);
                });
                
                nodes.forEach(node => {
                    if (node.parent) {
                        parentByChild.set(node.id, node.parent);
                        
                        if (!childrenByParent.has(node.parent)) {
                            childrenByParent.set(node.parent, []);
                        }
                        childrenByParent.get(node.parent).push(node.id);
                    }
                });
                
                for (let iter = 0; iter < iterations; iter++) {
                    // Copy positions to avoid modifying during iteration
                    const positionsCopy = new Map();
                    for (const [id, pos] of this.nodePositions.entries()) {
                        positionsCopy.set(id, { x: pos.x, y: pos.y, z: pos.z });
                    }
                    
                    // Repulsion forces - prevent node overlap
                    for (let i = 0; i < nodes.length; i++) {
                        const nodeA = nodes[i];
                        if (!this.nodePositions.has(nodeA.id)) continue;
                        
                        const posA = positionsCopy.get(nodeA.id);
                        const sizeA = nodeSizes.get(nodeA.id);
                        
                        for (let j = i + 1; j < nodes.length; j++) {
                            const nodeB = nodes[j];
                            if (!this.nodePositions.has(nodeB.id)) continue;
                            
                            const posB = positionsCopy.get(nodeB.id);
                            const sizeB = nodeSizes.get(nodeB.id);
                            
                            // Calculate distance
                            const dx = posB.x - posA.x;
                            const dy = posB.y - posA.y;
                            const dz = posB.z - posA.z;
                            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                            
                            // Calculate minimum distance based on both node sizes
                            const minDistance = sizeA + sizeB + baseSpacing;
                            
                            // Skip if nodes are far enough apart
                            if (distance >= minDistance) continue;
                            
                            // Skip if one node is the parent of the other - manage those with attraction
                            const isParentChild = 
                                parentByChild.get(nodeA.id) === nodeB.id || 
                                parentByChild.get(nodeB.id) === nodeA.id;
                            
                            if (isParentChild) continue;
                            
                            // Calculate required movement - less dampening for stronger repulsion
                            const levelFactorA = 1 / Math.max(1, nodeA.level * 0.5); // Reduced dampening
                            const levelFactorB = 1 / Math.max(1, nodeB.level * 0.5); // Reduced dampening
                            
                            const moveDistance = (minDistance - distance) * 0.6; // Stronger push (was / 2)
                            
                            // Avoid divide by zero
                            if (distance > 0.001) {
                                const moveX = (dx / distance) * moveDistance;
                                const moveY = (dy / distance) * moveDistance;
                                const moveZ = (dz / distance) * moveDistance;
                                
                                // Apply movement with level-based dampening
                                const posAFinal = this.nodePositions.get(nodeA.id);
                                const posBFinal = this.nodePositions.get(nodeB.id);
                                
                                posAFinal.x -= moveX * levelFactorA;
                                posAFinal.y -= moveY * levelFactorA;
                                posAFinal.z -= moveZ * levelFactorA;
                                
                                posBFinal.x += moveX * levelFactorB;
                                posBFinal.y += moveY * levelFactorB;
                                posBFinal.z += moveZ * levelFactorB;
                            }
                        }
                    }
                    
                    // Attraction forces - maintain parent-child distances
                    for (const [childId, parentId] of parentByChild.entries()) {
                        if (!this.nodePositions.has(childId) || !this.nodePositions.has(parentId)) continue;
                        
                        const childPos = this.nodePositions.get(childId);
                        const parentPos = this.nodePositions.get(parentId);
                        
                        // Calculate current distance
                        const dx = childPos.x - parentPos.x;
                        const dy = childPos.y - parentPos.y; 
                        const dz = childPos.z - parentPos.z;
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        // Get node sizes
                        const childSize = nodeSizes.get(childId);
                        const parentSize = nodeSizes.get(parentId);
                        
                        // Calculate ideal distance based on level and node sizes
                        const childNode = nodes.find(n => n.id === childId);
                        const baseDistance = 80 + 30 * childNode.level; // Increased base spacing for level
                        const targetDistance = baseDistance + (childSize + parentSize); // Full diameter spacing, not just radii
                        
                        // Only adjust if significantly off target
                        if (Math.abs(distance - targetDistance) > 10) {
                            // Avoid divide by zero
                            if (distance > 0.001) {
                                const factor = targetDistance / distance;
                                const newDx = dx * factor;
                                const newDy = dy * factor;
                                const newDz = dz * factor;
                                
                                // Move child to new position
                                childPos.x = parentPos.x + newDx;
                                childPos.y = parentPos.y + newDy;
                                childPos.z = parentPos.z + newDz;
                            }
                        }
                    }
                    
                    // Constraint forces - keep nodes within sphere and maintain radial distance
                    for (const node of nodes) {
                        if (!this.nodePositions.has(node.id)) continue;
                        
                        const pos = this.nodePositions.get(node.id);
                        const distFromCenter = Math.sqrt(pos.x * pos.x + pos.y * pos.y + pos.z * pos.z);
                        
                        // Skip root node
                        if (node.level === 0) continue;
                        
                        // Calculate target radius based on level
                        const maxLevel = Math.max(...nodes.map(n => n.level));
                        const levelProgress = node.level / (maxLevel + 1);
                        const targetRadius = sphereRadius * (0.3 + 0.65 * levelProgress); // More progressive scaling
                        
                        // Only adjust if significantly off target radius
                        if (Math.abs(distFromCenter - targetRadius) > 15) {
                            if (distFromCenter > 0.001) {
                                const factor = targetRadius / distFromCenter;
                                pos.x *= factor;
                                pos.y *= factor;
                                pos.z *= factor;
                            } else {
                                // Handle zero case with random placement on sphere
                                const phi = Math.random() * Math.PI * 2;
                                const theta = Math.random() * Math.PI;
                                
                                pos.x = targetRadius * Math.sin(theta) * Math.cos(phi);
                                pos.y = targetRadius * Math.sin(theta) * Math.sin(phi);
                                pos.z = targetRadius * Math.cos(theta);
                            }
                        }
                    }
                }
            }
            
            isDescendantOf(node, ancestorId, allNodes) {
                if (node.parent === ancestorId) return true;
                
                let currentNode = node;
                while (currentNode.parent) {
                    const parentNode = allNodes.find(n => n.id === currentNode.parent);
                    if (!parentNode) break;
                    
                    if (parentNode.id === ancestorId) return true;
                    currentNode = parentNode;
                }
                
                return false;
            }
            
            createNodeObjects(nodes) {
                // Clear existing nodes first thoroughly
                this.nodes.forEach((nodeMesh, nodeId) => {
                    this.scene.remove(nodeMesh);
                    if (nodeMesh.geometry) nodeMesh.geometry.dispose();
                    if (nodeMesh.material) {
                        if (Array.isArray(nodeMesh.material)) {
                            nodeMesh.material.forEach(mat => mat.dispose());
                        } else {
                            nodeMesh.material.dispose();
                        }
                    }
                });
                this.nodes.clear();
                
                // Create a shared geometry map to reuse geometries
                const geometries = new Map();
                
                // Create individual mesh for each node
                nodes.forEach(nodeData => {
                    const size = this.getNodeSize(nodeData.type, nodeData.level);
                    const geometryKey = `${nodeData.type}-${size}`;
                    
                    // Reuse geometry if already created
                    if (!geometries.has(geometryKey)) {
                        geometries.set(geometryKey, new THREE.SphereGeometry(size, 32, 32));
                    }
                    
                    const geometry = geometries.get(geometryKey);
                    const color = this.getNodeColor(nodeData.type);
                    const material = new THREE.MeshPhongMaterial({
                        color: color,
                        shininess: 80,
                        emissive: new THREE.Color(color).multiplyScalar(0.2)
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData = { 
                        node: nodeData,
                        nodeId: nodeData.id,  // Important: Add nodeId explicitly for raycasting
                        originalOpacity: material.opacity || 1.0  // Store initial opacity
                    };
                    mesh.frustumCulled = true; // Enable culling for performance
                    
                    if (this.nodePositions.has(nodeData.id)) {
                        const pos = this.nodePositions.get(nodeData.id);
                        mesh.position.set(pos.x, pos.y, pos.z);
                    }
                    
                    // Add to scene
                    this.scene.add(mesh);
                    this.nodes.set(nodeData.id, mesh);
                });
            }
            
            createLinkObjects(links) {
                // Clear existing links thoroughly
                this.links.forEach((link, linkId) => {
                    this.scene.remove(link);
                    if (link.geometry) link.geometry.dispose();
                    if (link.material) {
                        if (Array.isArray(link.material)) {
                            link.material.forEach(mat => mat.dispose());
                        } else {
                            link.material.dispose();
                        }
                    }
                });
                this.links.clear();
                
                // Handle case where links parameter is not provided
                const linksToUse = links || this.getVisibleLinks([]);
                
                // Create shared materials map to reduce material instances
                const materials = new Map();
                
                linksToUse.forEach(link => {
                    // Handle potentially varying link structure - source and target might be objects or strings
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    
                    const sourceNode = this.nodes.get(sourceId);
                    const targetNode = this.nodes.get(targetId);
                    
                    if (!sourceNode || !targetNode) return;
                    
                    // Get positions
                    const sourcePos = sourceNode.position.clone();
                    const targetPos = targetNode.position.clone();
                    
                    // Determine color, opacity, and line style based on relationship type
                    let color, opacity, lineWidth, dashSize, gapSize;
                    const linkType = link.type || 'default';
                    
                    switch(linkType) {
                        case 'contains':
                            color = 0xb4b4b4; // Light grey
                            opacity = 0.15;
                            lineWidth = 0.5;
                            break;
                        case 'implements':
                            color = 0x64c864; // Green
                            opacity = 0.25;
                            lineWidth = 0.7;
                            dashSize = 4;
                            gapSize = 4;
                            break;
                        case 'integration_point':
                            color = 0x6496ff; // Blue
                            opacity = 0.25;
                            lineWidth = 0.7;
                            dashSize = 2;
                            gapSize = 2;
                            break;
                        case 'provides_input_to':
                            color = 0xff9632; // Orange
                            opacity = 0.25;
                            lineWidth = 0.7;
                            break;
                        case 'complements':
                            color = 0x9664ff; // Purple
                            opacity = 0.25;
                            lineWidth = 0.7;
                            break;
                        case 'informs':
                            color = 0x64ff96; // Light green
                            opacity = 0.25;
                            lineWidth = 0.7;
                            break;
                        case 'extends':
                            color = 0xff6464; // Red
                            opacity = 0.25;
                            lineWidth = 0.7;
                            break;
                        case 'bidirectional':
                            color = 0xffc832; // Gold
                            opacity = 0.25;
                            lineWidth = 0.7;
                            dashSize = 6;
                            gapSize = 3;
                            break;
                        default:
                            color = 0xb4b4b4; // Light grey
                            opacity = 0.15;
                            lineWidth = 0.5;
                    }
                    
                    // Create individual material for each link to allow independent highlighting
                    // Note: We don't share materials anymore to enable individual link highlighting
                    const material = new THREE.LineBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: opacity,
                        linewidth: lineWidth
                    });
                    
                    // If dash pattern specified, convert to dashed line material
                    if (dashSize && gapSize) {
                        material.dashed = true;
                        material.dashSize = dashSize;
                        material.gapSize = gapSize;
                    }
                    
                    // Store original properties for reset functionality
                    material.userData = {
                        originalColor: color,
                        originalOpacity: opacity,
                        originalLineWidth: lineWidth,
                        linkType: linkType
                    };
                    
                    // Create curved path between nodes
                    // For nearby nodes, use straight lines
                    // For distant nodes, add curvature
                    const distance = sourcePos.distanceTo(targetPos);
                    let linkGeometry;
                    
                    if (distance < 50) {
                        // For close nodes, use straight line
                        const points = [sourcePos, targetPos];
                        linkGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    } else {
                        // For distant nodes, create curved link
                        const midPoint = sourcePos.clone().add(targetPos).multiplyScalar(0.5);
                        
                        // Add curve perpendicular to line connecting nodes
                        const lineDirection = targetPos.clone().sub(sourcePos).normalize();
                        
                        // Create perpendicular direction (in 3D space)
                        const perpendicular = new THREE.Vector3(
                            -lineDirection.z,
                            lineDirection.y,
                            lineDirection.x
                        ).normalize();
                        
                        // Curve height based on distance and relationship type
                        let curveHeight = Math.min(distance * 0.2, 50);
                        
                        // Adjust curve height for different relationship types
                        if (linkType === 'implements' || linkType === 'integration_point') {
                            curveHeight *= 1.2; // Higher curve for implementation/integration relationships
                        } else if (linkType === 'bidirectional') {
                            curveHeight *= 0.8; // Lower curve for bidirectional relationships
                        }
                        
                        // Control point is midpoint raised in perpendicular direction
                        const controlPoint = midPoint.clone().add(
                            perpendicular.clone().multiplyScalar(curveHeight)
                        );
                        
                        // Create quadratic curve
                        const curve = new THREE.QuadraticBezierCurve3(
                            sourcePos,
                            controlPoint,
                            targetPos
                        );
                        
                        // Sample points along curve
                        const points = curve.getPoints(20);
                        linkGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    }
                    
                    // Create the line
                    const line = new THREE.Line(linkGeometry, material);
                    line.userData = {
                        source: sourceId,
                        target: targetId,
                        type: linkType,
                        description: link.description || ""
                    };
                    
                    // Generate a unique ID for the link if not present
                    const linkId = link.id || `${sourceId}-${targetId}`;
                    this.links.set(linkId, line);
                    
                    // Add to scene
                    this.scene.add(line);
                });
                
                console.log(`Created ${this.links.size} links`);
            }
            
            // Control functions
            zoomIn() {
                const targetZ = this.camera.position.z * 0.8;
                this.camera.position.z = targetZ;
                this.controls.update();
                this.cameraControlsNeedUpdate = true;
            }
            
            zoomOut() {
                const targetZ = this.camera.position.z * 1.2;
                this.camera.position.z = targetZ;
                this.controls.update();
                this.cameraControlsNeedUpdate = true;
            }
            
            resetView() {
                // Reset to initial state: only root node expanded, camera at initial position
                console.log("Resetting to initial state");
                
                // Reset expand-all button to its original electrical state
                const expandAllButton = document.getElementById('expand-all');
                if (expandAllButton && expandAllButton.classList.contains('first-clicked')) {
                    expandAllButton.classList.remove('first-clicked');
                    console.log("Expand All button reset to electrical state - animation re-enabled");
                }
                
                // Reset expanded nodes to initial state (only root)
                this.expandedNodes.clear();
                const rootNode = this.graphData.nodes.find(node => node.level === 0);
                if (rootNode) {
                    this.expandedNodes.add(rootNode.id);
                }
                
                // Clear all visual elements and rebuild to initial state
                this.clearAllVisualElements();
                
                // Get initial visible nodes (should be just root)
                const visibleNodes = this.getVisibleNodes();
                
                // Rebuild visualization in initial state
                this.positionNodes(visibleNodes);
                this.createNodeObjects(visibleNodes);
                this.createLinkObjects(this.getVisibleLinks(visibleNodes));
                this.setupNodeAnimations(visibleNodes);
                
                // Reset camera to initial position
                this.camera.position.set(0, 0, 1000);
                this.controls.target.set(0, 0, 0);
                this.scene.rotation.set(0, 0, 0);
                this.controls.reset();
                this.controls.update();
                this.cameraControlsNeedUpdate = true;
                
                // Reset rotation state
                this.isRotating = false;
                this.updateRotationButton();
                
                // Clear any selected node (return to default info page)
                this.selectedNode = null;
                
                // If details panel is open, show default info page
                const detailsPanel = document.getElementById('details-panel');
                const isPanelVisible = detailsPanel && !detailsPanel.classList.contains('hidden');
                if (isPanelVisible) {
                    this.displayDefaultInfoPage();
                }
                
                console.log(`Reset to initial state: ${visibleNodes.length} visible nodes`);
            }
            
            toggleRotation() {
                this.isRotating = !this.isRotating;
                // Reset frame time to ensure smooth rotation start
                this.lastFrameTime = null;
                this.updateRotationButton();
                console.log(`Rotation ${this.isRotating ? 'enabled' : 'disabled'}`);
            }
            
            updateRotationButton() {
                const toggleButton = document.getElementById('toggle-rotation');
                
                if (toggleButton) {
                    // Set button text to simply "Rotate"
                    toggleButton.textContent = 'Rotate';
                    
                    if (this.isRotating) {
                        // Active state - add active class for panel toggle styling (dark color)
                        toggleButton.classList.add('active');
                        console.log("Rotation button set to active state");
                    } else {
                        // Inactive state - remove active class for default white style
                        toggleButton.classList.remove('active');
                        console.log("Rotation button set to inactive state");
                    }
                }
            }
            
            // Ultra-fast visualization update that skips expensive operations
            fastUpdateVisualization(visibleNodes) {
                // Only create objects for nodes that don't already exist
                const existingNodeIds = new Set(this.nodes.keys());
                const newNodes = visibleNodes.filter(node => !existingNodeIds.has(node.id));
                
                if (newNodes.length > 0) {
                    // Only position and create new nodes, don't touch existing ones
                    newNodes.forEach(nodeData => {
                        if (!this.nodePositions.has(nodeData.id)) {
                            // Quick positioning for new nodes only
                            const parentPos = nodeData.parent ? this.nodePositions.get(nodeData.parent) : { x: 0, y: 0, z: 0 };
                            if (parentPos) {
                                const offset = Math.random() * 100 - 50;
                                this.nodePositions.set(nodeData.id, {
                                    x: parentPos.x + offset,
                                    y: parentPos.y + offset,
                                    z: parentPos.z + offset
                                });
                            }
                        }
                    });
                    
                    // Create objects only for new nodes
                    this.createNodeObjectsSelective(newNodes);
                }
                
                // Update links efficiently
                this.updateLinksSelective(visibleNodes);
            }
            
            // Create node objects only for specific nodes (much faster)
            createNodeObjectsSelective(nodes) {
                const geometries = new Map();
                
                nodes.forEach(nodeData => {
                    const size = this.getNodeSize(nodeData.type, nodeData.level);
                    const geometryKey = `${nodeData.type}-${size}`;
                    
                    if (!geometries.has(geometryKey)) {
                        geometries.set(geometryKey, new THREE.SphereGeometry(size, 32, 32));
                    }
                    
                    const geometry = geometries.get(geometryKey);
                    const color = this.getNodeColor(nodeData.type);
                    const material = new THREE.MeshPhongMaterial({
                        color: color,
                        shininess: 80,
                        emissive: new THREE.Color(color).multiplyScalar(0.2)
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData = { 
                        node: nodeData,
                        nodeId: nodeData.id,
                        originalOpacity: material.opacity || 1.0  // Store initial opacity
                    };
                    
                    if (this.nodePositions.has(nodeData.id)) {
                        const pos = this.nodePositions.get(nodeData.id);
                        mesh.position.set(pos.x, pos.y, pos.z);
                    }
                    
                    this.scene.add(mesh);
                    this.nodes.set(nodeData.id, mesh);
                });
            }
            
            // Update links selectively (only create missing links)
            updateLinksSelective(visibleNodes) {
                const visibleLinks = this.getVisibleLinks(visibleNodes);
                const existingLinkIds = new Set(this.links.keys());
                
                visibleLinks.forEach(link => {
                    const linkId = link.id || `${link.source}-${link.target}`;
                    if (!existingLinkIds.has(linkId)) {
                        // Create only missing links
                        this.createSingleLink(link, linkId);
                    }
                });
            }
            
            // Create a single link efficiently
            createSingleLink(link, linkId) {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                
                const sourceNode = this.nodes.get(sourceId);
                const targetNode = this.nodes.get(targetId);
                
                if (!sourceNode || !targetNode) return;
                
                const sourcePos = sourceNode.position.clone();
                const targetPos = targetNode.position.clone();
                
                const material = new THREE.LineBasicMaterial({
                    color: 0xb4b4b4,
                    transparent: true,
                    opacity: 0.15
                });
                
                // Store original properties for reset functionality
                material.userData = {
                    originalColor: 0xb4b4b4,
                    originalOpacity: 0.15,
                    originalLineWidth: 0.5,
                    linkType: link.type || 'default'
                };
                
                const points = [sourcePos, targetPos];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, material);
                
                line.userData = {
                    source: sourceId,
                    target: targetId,
                    type: link.type || 'default'
                };
                
                this.links.set(linkId, line);
                this.scene.add(line);
            }
            
            // Fast selective removal of specific descendants (much faster than full cleanup)
            selectivelyRemoveDescendants(parentNodeId) {
                const descendantsToRemove = this.findAllDescendants(parentNodeId);
                
                // Remove only the descendant nodes and their links
                descendantsToRemove.forEach(nodeId => {
                    const nodeMesh = this.nodes.get(nodeId);
                    if (nodeMesh) {
                        this.scene.remove(nodeMesh);
                        if (nodeMesh.geometry) nodeMesh.geometry.dispose();
                        if (nodeMesh.material) nodeMesh.material.dispose();
                        this.nodes.delete(nodeId);
                    }
                });
                
                // Remove links that connect to removed nodes
                const linksToRemove = [];
                this.links.forEach((link, linkId) => {
                    const sourceId = link.userData.source;
                    const targetId = link.userData.target;
                    if (descendantsToRemove.includes(sourceId) || descendantsToRemove.includes(targetId)) {
                        this.scene.remove(link);
                        if (link.geometry) link.geometry.dispose();
                        if (link.material) link.material.dispose();
                        linksToRemove.push(linkId);
                    }
                });
                
                linksToRemove.forEach(linkId => this.links.delete(linkId));
                console.log(`Selectively removed ${descendantsToRemove.length} nodes and ${linksToRemove.length} links`);
            }
            
            // Helper method to completely clear all visual elements from the scene
            clearAllVisualElements() {
                console.log("Clearing all visual elements...");
                
                // Clear all nodes
                this.nodes.forEach((nodeMesh, nodeId) => {
                    this.scene.remove(nodeMesh);
                    if (nodeMesh.geometry) nodeMesh.geometry.dispose();
                    if (nodeMesh.material) nodeMesh.material.dispose();
                });
                this.nodes.clear();
                
                // Clear all links
                this.links.forEach((link, linkId) => {
                    this.scene.remove(link);
                    if (link.geometry) link.geometry.dispose();
                    if (link.material) link.material.dispose();
                });
                this.links.clear();
                
                // Clear node animations
                this.nodeAnimations.clear();
                
                // Force garbage collection of any remaining objects in the scene
                // by traversing and removing any orphaned objects
                const objectsToRemove = [];
                this.scene.traverse((object) => {
                    if (object !== this.scene && object.type !== 'AmbientLight' && object.type !== 'DirectionalLight') {
                        // Check if this object is a mesh, line, or any other renderable object that should be removed
                        // Skip the bounding sphere if it exists (though it shouldn't be in scene anymore)
                        if ((object.type === 'Mesh' || object.type === 'Line' || object.type === 'LineSegments' || 
                            object.type === 'Points' || object.type === 'Sprite') && 
                            object.name !== 'boundingSphere') {
                            objectsToRemove.push(object);
                        }
                    }
                });
                
                // Remove any orphaned objects
                objectsToRemove.forEach(object => {
                    this.scene.remove(object);
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(mat => mat.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                    // Also dispose of any textures
                    if (object.material && object.material.map) object.material.map.dispose();
                    if (object.material && object.material.normalMap) object.material.normalMap.dispose();
                    if (object.material && object.material.emissiveMap) object.material.emissiveMap.dispose();
                });
                
                console.log(`Cleared ${objectsToRemove.length} orphaned objects from scene`);
            }
            
            // Expand all nodes in the graph
            expandAllNodes() {
                console.log("Expanding all nodes...");
                
                // Mark expand-all button as first-clicked to disable electrical animation
                const expandAllButton = document.getElementById('expand-all');
                if (expandAllButton && !expandAllButton.classList.contains('first-clicked')) {
                    expandAllButton.classList.add('first-clicked');
                    console.log("Expand All button marked as first-clicked - electrical animation disabled");
                }
                
                // Guard against multiple calls
                if (this._processingExpansion) {
                    console.log("Already processing expansion/collapse, please wait");
                    return;
                }
                
                this._processingExpansion = true;
                
                try {
                    // First, completely clear all existing visual elements to prevent orphaned objects
                    this.clearAllVisualElements();
                    
                    // Add all nodes to the expanded set
                    for (const node of this.graphData.nodes) {
                        this.expandedNodes.add(node.id);
                    }
                    
                    // Update the visualization
                    const visibleNodes = this.getVisibleNodes();
                    const visibleLinks = this.getVisibleLinks(visibleNodes);
                    
                    // Position nodes and update visual elements
                    this.positionNodes(visibleNodes);
                    this.createNodeObjects(visibleNodes);
                    this.createLinkObjects(visibleLinks);
                    this.setupNodeAnimations(visibleNodes);
                    
                    console.log(`Expanded to ${visibleNodes.length} nodes and ${visibleLinks.length} links`);
                } catch (error) {
                    console.error("Error expanding all nodes:", error);
                } finally {
                    // Clear the processing flag after a short delay
                    setTimeout(() => {
                        this._processingExpansion = false;
                    }, 500);
                }
            }
            
            // Collapse all nodes except the root
            collapseAllNodes() {
                console.log("Collapsing all nodes...");
                
                // Reset expand-all button to its original electrical state
                const expandAllButton = document.getElementById('expand-all');
                if (expandAllButton && expandAllButton.classList.contains('first-clicked')) {
                    expandAllButton.classList.remove('first-clicked');
                    console.log("Expand All button reset to electrical state - animation re-enabled");
                }
                
                // Guard against multiple calls
                if (this._processingExpansion) {
                    console.log("Already processing expansion/collapse, please wait");
                    return;
                }
                
                this._processingExpansion = true;
                
                try {
                    // Find the root node
                    const rootNode = this.graphData.nodes.find(node => node.level === 0);
                    if (!rootNode) {
                        console.error("Root node not found");
                        return;
                    }
                    
                    // Reset expanded nodes completely
                    this.expandedNodes.clear();
                    
                    // Only add root node to expanded set
                    this.expandedNodes.add(rootNode.id);
                    
                    // Use comprehensive cleanup to ensure no orphaned objects remain
                    this.clearAllVisualElements();
                    
                    // Get visible nodes - should be just the root now
                    const visibleNodes = this.getVisibleNodes();
                    
                    // Re-create necessary objects
                    this.positionNodes(visibleNodes);
                    this.createNodeObjects(visibleNodes);
                    this.createLinkObjects(this.getVisibleLinks(visibleNodes));
                    this.setupNodeAnimations(visibleNodes);
                    
                    // Focus on root
                    if (rootNode) {
                        const position = this.nodePositions.get(rootNode.id);
                        if (position) {
                            this.navigateToPosition(position.x, position.y, position.z);
                        }
                    }
                    
                    console.log(`Collapsed to ${visibleNodes.length} nodes`);
                } catch (error) {
                    console.error("Error collapsing all nodes:", error);
                } finally {
                    // Clear the processing flag after a short delay
                    setTimeout(() => {
                        this._processingExpansion = false;
                    }, 500);
                }
            }
            
            // Add new method to force expanding children for a given specification node
            forceExpandChildren(specificationId) {
                console.log(`Force expanding children for specification: ${specificationId}`);
                
                if (!this.graphData || !this.graphData.nodes) {
                    console.error("No graph data available");
                    return;
                }
                
                // First ensure the specification node is in our graph data
                const specNode = this.graphData.nodes.find(n => n.id === specificationId);
                if (!specNode) {
                    console.error(`Specification node not found: ${specificationId}`);
                    return;
                }
                
                // Make sure the specification node and all its ancestors are expanded
                this.ensureNodeVisible(specNode);
                
                // Find all direct children of this specification node
                const childNodes = this.graphData.nodes.filter(n => n.parent === specificationId);
                
                // Expand each child
                childNodes.forEach(child => {
                    this.expandedNodes.add(child.id);
                    
                    // Recursively expand grandchildren
                    const grandchildren = this.graphData.nodes.filter(n => n.parent === child.id);
                    grandchildren.forEach(grandchild => {
                        this.expandedNodes.add(grandchild.id);
                    });
                });
                
                // Update visualization
                const visibleNodes = this.getVisibleNodes();
                this.positionNodes(visibleNodes);
                this.createNodeObjects(visibleNodes);
                this.createLinkObjects(this.getVisibleLinks(visibleNodes));
                
                // Update animations for newly visible nodes
                this.setupNodeAnimations(visibleNodes);
                
                // Select the specification node to focus on it
                this.selectNode(specNode);
            }
            
            // New method to specifically select the root node using a dedicated endpoint
            async selectRootNode(rootNode) {
                // Update UI to show selected node details
                const detailsContent = document.getElementById('details-content');
                
                // Show loading indicator
                detailsContent.innerHTML = `
                    <div class="loading-indicator">
                        <div class="spinner"></div>
                        <span>Loading details...</span>
                    </div>
                `;
                
                try {
                    // Use the dedicated root endpoint
                    console.log("Fetching root node details from dedicated endpoint");
                    const response = await fetch('/api/root');
                    
                    if (!response.ok) {
                        console.error(`Error loading root details: ${response.status} ${response.statusText}`);
                        detailsContent.innerHTML = `
                            <div class="error-message">
                                <h3>Error</h3>
                                <p>Could not load root details: ${response.statusText}</p>
                                <p>Status: ${response.status}</p>
                            </div>
                        `;
                        return;
                    }
                    
                    const detailsData = await response.json();
                    
                    if (detailsData.error) {
                        detailsContent.innerHTML = `
                            <div class="error-message">
                                <h3>Error</h3>
                                <p>${detailsData.error}</p>
                            </div>
                        `;
                        return;
                    }
                    
                    this.displayNodeDetails(detailsData);
                    this.updateBreadcrumbs(rootNode.id);
                    
                    // Track selected node
                    this.selectedNode = rootNode;
                    
                    // Highlight the selected node
                    this.highlightSelectedNode(rootNode.id);
                } catch (error) {
                    console.error(`Error in selectRootNode: ${error}`);
                    detailsContent.innerHTML = `
                        <div class="error-message">
                            <h3>Error</h3>
                            <p>An unexpected error occurred: ${error.message}</p>
                        </div>
                    `;
                }
            }
            
            // Helper method to find node data in backend data
            async findNodeInBackendData(nodeId) {
                if (!nodeId) return null;
                
                // First check if it's a direct node in graphData
                const node = this.graphData.nodes.find(n => n.id === nodeId);
                if (!node) return null;
                
                try {
                    // Special handling for root node
                    if (nodeId === "ai-alignment" || node.level === 0) {
                        console.log("Using root endpoint for node data");
                        const response = await fetch('/api/root');
                        
                        if (!response.ok) {
                            console.error(`Error fetching root data: ${response.status} ${response.statusText}`);
                            return null;
                        }
                        
                        const data = await response.json();
                        console.log("Successfully fetched root data:", data);
                        return data;
                    }
                    
                    // For all other node types, fetch the complete data from the backend
                    console.log(`Fetching complete data for node: ${nodeId}`);
                    const response = await fetch(`/api/details/${nodeId}`);
                    
                    if (!response.ok) {
                        console.error(`Error fetching node data: ${response.status} ${response.statusText}`);
                        return null;
                    }
                    
                    const data = await response.json();
                    console.log(`Successfully fetched data for ${nodeId}:`, data);
                    return data;
                } catch (error) {
                    console.error(`Error fetching node data: ${error}`);
                    return null;
                }
            }
            
            // Method to select a node and display its details
            async selectNode(nodeData) {
                if (!nodeData) return;
                
                console.log(`Selecting node: ${nodeData.name} (${nodeData.id})`);
                
                // Store current scroll position before navigating away
                if (this.selectedNode) {
                    const scrollContainer = document.querySelector('.single-scrollable-container');
                    if (scrollContainer) {
                        this.scrollPositions.set(this.selectedNode.id, scrollContainer.scrollTop);
                    }
                }
                
                // Only add to history if it's a new navigation, not going back/forward
                const isNewNavigation = !this._isHistoryNavigation;
                if (isNewNavigation) {
                    // If we're in the middle of the history and navigating to a new node,
                    // truncate the forward history
                    if (this.currentNodeIndex >= 0 && this.currentNodeIndex < this.navigationHistory.length - 1) {
                        this.navigationHistory = this.navigationHistory.slice(0, this.currentNodeIndex + 1);
                    }
                    
                    // Add this node to history
                    this.navigationHistory.push(nodeData.id);
                    this.currentNodeIndex = this.navigationHistory.length - 1;
                    
                    // Update back button visibility
                    this.updateBackButtonVisibility();
                }
                
                // Reset the history navigation flag
                this._isHistoryNavigation = false;
                
                // Update selected node reference
                this.selectedNode = nodeData;
                
                // Find and highlight the node visually
                const nodeMesh = this.nodes.get(nodeData.id);
                if (nodeMesh) {
                    // Reset all node materials first
                    this.nodes.forEach((mesh, id) => {
                        if (mesh.material && mesh.material.emissive) {
                            mesh.material.emissive.setScalar(0.05);
                            mesh.scale.set(1, 1, 1);
                        }
                    });
                    
                    // Reset all link highlights first
                    this.resetLinkHighlights();
                    
                    // Highlight the selected node
                    if (nodeMesh.material && nodeMesh.material.emissive) {
                        // Don't change the base color, only increase emissive intensity
                        nodeMesh.material.emissiveIntensity = 0.5;
                        nodeMesh.scale.set(1.2, 1.2, 1.2);
                    }
                    
                    // Highlight connected links
                    this.highlightConnectedLinks(nodeData.id);
                    
                    // Move camera to focus on this node
                    const position = this.nodePositions.get(nodeData.id);
                    if (position) {
                        this.navigateToPosition(position.x, position.y, position.z);
                    }
                }
                
                // Only update panel content if the panel is currently visible
                const detailsPanel = document.getElementById('details-panel');
                const isPanelVisible = detailsPanel && !detailsPanel.classList.contains('hidden');
                
                if (isPanelVisible) {
                    // Update UI with node details
                    const detailsContent = document.getElementById('details-content');
                    
                    if (detailsContent) {
                        
                        // Show loading indicator
                        detailsContent.innerHTML = `
                            <div class="loading-indicator">
                                <div class="spinner"></div>
                                <span>Loading details...</span>
                            </div>
                        `;
                        
                        try {
                            // Try to get complete node data
                            const fullNodeData = await this.findNodeInBackendData(nodeData.id);
                            
                            if (fullNodeData) {
                                // Display the complete node details
                                this.displayNodeDetails(fullNodeData);
                                
                                // Update breadcrumbs
                                this.updateBreadcrumbs(nodeData.id);
                                
                                // Restore scroll position if navigating back
                                if (this.scrollPositions.has(nodeData.id)) {
                                    const scrollContainer = document.querySelector('.single-scrollable-container');
                                    if (scrollContainer) {
                                        setTimeout(() => {
                                            scrollContainer.scrollTop = this.scrollPositions.get(nodeData.id);
                                        }, 100); // Short delay to ensure content is rendered
                                    }
                                } else {
                                    // Scroll to top for new nodes
                                    const scrollContainer = document.querySelector('.single-scrollable-container');
                                    if (scrollContainer) {
                                        scrollContainer.scrollTop = 0;
                                    }
                                }
                            } else {
                                // If API fetch fails, use the basic node data we have
                                this.displayNodeDetails(nodeData);
                            }
                        } catch (error) {
                            console.error(`Error fetching node details: ${error}`);
                            // Fall back to basic data
                            this.displayNodeDetails(nodeData);
                        }
                    }
                }
                
                // Highlight the node in the visualization
                this.highlightSelectedNode(nodeData.id);
            }
            
            // Method to deselect the current node and show default info
            deselectNode() {
                console.log("Deselecting current node");
                
                // Store current scroll position if there was a selected node
                if (this.selectedNode) {
                    const scrollContainer = document.querySelector('.single-scrollable-container');
                    if (scrollContainer) {
                        this.scrollPositions.set(this.selectedNode.id, scrollContainer.scrollTop);
                    }
                }
                
                // Clear the selected node
                this.selectedNode = null;
                
                // Reset all node visual highlights
                this.resetAllNodeHighlights();
                
                // If the details panel is visible, update it to show the default info page
                const detailsPanel = document.getElementById('details-panel');
                const isPanelVisible = detailsPanel && !detailsPanel.classList.contains('hidden');
                
                if (isPanelVisible) {
                    this.displayDefaultInfoPage();
                }
            }
            
            // Reset all node highlights to their normal appearance
            resetAllNodeHighlights() {
                this.nodes.forEach((nodeMesh, id) => {
                    // Skip if this is an instanced node (those are handled differently)
                    if (nodeMesh.isInstancedNode) return;
                    
                    // Reset to original color
                    const nodeData = this.graphData.nodes.find(n => n.id === id);
                    if (nodeData && nodeMesh.material) {
                        const color = this.getNodeColor(nodeData.type);
                        nodeMesh.material.color.set(color);
                        
                        // Reset size
                        nodeMesh.scale.set(1, 1, 1);
                        
                        // Reset emissive properties if they exist
                        if (nodeMesh.material.emissive) {
                            nodeMesh.material.emissive.setScalar(0.2);
                            nodeMesh.material.emissiveIntensity = 0.3;
                        }
                    }
                });
                
                // Reset all links to normal opacity and visibility
                this.links.forEach((linkMesh, linkId) => {
                    if (linkMesh.material) {
                        const userData = linkMesh.userData;
                        const sourceId = userData.source;
                        const targetId = userData.target;
                        
                        // Check if both source and target nodes actually exist
                        const sourceExists = this.nodes.has(sourceId);
                        const targetExists = this.nodes.has(targetId);
                        
                        if (!sourceExists || !targetExists) {
                            // Keep orphaned links hidden
                            linkMesh.visible = false;
                        } else {
                            // Make valid links visible again
                            linkMesh.visible = true;
                            const materialData = linkMesh.material.userData;
                            linkMesh.material.opacity = materialData.originalOpacity || 0.15;
                            if (materialData.dimmedOpacity) {
                                delete materialData.dimmedOpacity;
                            }
                        }
                    }
                });
                
                // Reset all link highlights
                this.resetLinkHighlights();
            }
            
            // Display node details in the details panel
            displayNodeDetails(nodeData) {
                const detailsContent = document.getElementById('details-content');
                
                if (!detailsContent) {
                    console.error("Details content element not found");
                    return;
                }
                
                try {
                    if (!nodeData) {
                        console.error("No node data provided to displayNodeDetails");
                        detailsContent.innerHTML = `
                            <div class="error-message">
                                <h3>Error</h3>
                                <p>No node data provided</p>
                            </div>
                        `;
                        return;
                    }
                    
                    // Check for errors in the node data
                    if (nodeData.error) {
                        detailsContent.innerHTML = `
                            <div class="error-message">
                                <h3>Error</h3>
                                <p>${nodeData.error}</p>
                            </div>
                        `;
                        return;
                    }
                    
                    // Use the node details renderer to generate the HTML
                    const html = nodeDetailsRenderer.renderNodeDetails(nodeData);
                    
                    // Set the content
                    detailsContent.innerHTML = html;
                    
                    // Update breadcrumbs
                    if (nodeData.id) {
                        this.updateBreadcrumbs(nodeData.id).catch(err => {
                            console.error("Error updating breadcrumbs:", err);
                        });
                    }
                    
                    // Add event listeners to clickable items - use enhanced setup from renderer
                    nodeDetailsRenderer.setupClickableItems(detailsContent);
                } catch (error) {
                    console.error("Error rendering node details:", error);
                    detailsContent.innerHTML = `
                        <div class="error-message">
                            <h3>Error</h3>
                            <p>An error occurred while rendering node details: ${error.message}</p>
                            <pre>${error.stack}</pre>
                        </div>
                    `;
                }
            }
            
            // Update literature references in the side panel
            updateLiteratureReferences(nodeData) {
                // We'll now handle literature references directly in the node details renderer
                // This function is kept for backwards compatibility
                console.log("Literature references are now handled by the node details renderer");
            }
            
            // Display literature references or hide section if none
            displayLiteratureReferences(references, container) {
                // This function is no longer needed as literature is handled by the renderer
                console.log("Literature references are now handled by the node details renderer");
            }
            
            // Hide literature section when no references are available
            hideLiteratureSection(container) {
                // This function is no longer needed as literature is handled by the renderer
                console.log("Literature references are now handled by the node details renderer");
            }
            
            // Setup click events for clickable items in the details panel
            setupClickableItems(container) {
                // Find all clickable items
                const clickableItems = container.querySelectorAll('.clickable-item, .subcomponent-link, .function-link, .technique-link');
                
                // Add click handler to each
                clickableItems.forEach(item => {
                    item.addEventListener('click', () => {
                        const nodeId = item.dataset.nodeId;
                        if (!nodeId) return;
                        
                        // Always force expand the node when clicked in details panel
                        const shouldExpand = true;
                        
                        // Find node in the graph data
                        const nodeData = this.graphData.nodes.find(n => n.id === nodeId);
                        if (nodeData) {
                            console.log(`Clicking on node ${nodeData.name} (${nodeData.id}) with expand=${shouldExpand}`);
                            
                            // If we should expand and node is not already expanded, expand it
                            if (shouldExpand && !this.expandedNodes.has(nodeId)) {
                                console.log(`Expanding node ${nodeData.id}`);
                                this.expandedNodes.add(nodeId);
                                
                                // If node has a parent, ensure parent is expanded too
                                this.ensureNodeVisible(nodeData);
                                
                                // Update the visualization with new expanded nodes
                                const visibleNodes = this.getVisibleNodes();
                                this.positionNodes(visibleNodes);
                                this.createNodeObjects(visibleNodes);
                                this.createLinkObjects(this.getVisibleLinks(visibleNodes));
                                this.setupNodeAnimations(visibleNodes);
                            }
                            
                            // Navigate to this node
                            this.selectNode(nodeData);
                        } else {
                            console.warn(`Node with ID ${nodeId} not found in graph data`);
                        }
                    });
                });
            }
            
            // Update breadcrumbs showing the path to the selected node
            async updateBreadcrumbs(nodeId) {
                const breadcrumbContainer = document.querySelector('.breadcrumb-container');
                if (!breadcrumbContainer) return;
                
                try {
                    // Fetch hierarchy path from API
                    const response = await fetch(`/api/hierarchy-path/${nodeId}`);
                    if (!response.ok) {
                        console.error(`Failed to fetch hierarchy path: ${response.statusText}`);
                        return;
                    }
                    
                    const pathData = await response.json();
                    if (!pathData.path || !pathData.path.length) {
                        console.error('Invalid path data received');
                        return;
                    }
                    
                    // Always show breadcrumbs now that we have "About" as home
                    // Even root nodes should show: About › Root Node
                    
                    // Build breadcrumb HTML starting with "About" home link
                    let breadcrumbHtml = `
                        <div class="breadcrumb-item clickable about-link">About</div>
                        <div class="breadcrumb-separator">›</div>
                    `;
                    
                    pathData.path.forEach((node, index) => {
                        // Skip showing duplicate node names in succession
                        if (index > 0 && node.name === pathData.path[index-1].name) {
                            return;
                        }
                        
                        // For each node in the path
                        const isLast = index === pathData.path.length - 1;
                        
                        if (isLast) {
                            // Current node (last in path)
                            breadcrumbHtml += `<div class="breadcrumb-item">${node.name}</div>`;
                        } else {
                            // Ancestor node (clickable)
                            breadcrumbHtml += `
                                <div class="breadcrumb-item clickable" data-node-id="${node.id}">${node.name}</div>
                                <div class="breadcrumb-separator">›</div>
                            `;
                        }
                    });
                    
                    // Set breadcrumb content
                    breadcrumbContainer.innerHTML = breadcrumbHtml;
                    
                    // Add click handlers to breadcrumb items
                    const clickableItems = breadcrumbContainer.querySelectorAll('.breadcrumb-item.clickable');
                    clickableItems.forEach(item => {
                        item.addEventListener('click', () => {
                            if (item.classList.contains('about-link')) {
                                // Handle "About" link click - return to default info page
                                this.deselectNode();
                            } else {
                                // Handle regular node breadcrumb click
                                const nodeId = item.dataset.nodeId;
                                if (nodeId) {
                                    const nodeData = this.graphData.nodes.find(n => n.id === nodeId);
                                    if (nodeData) {
                                        this.navigateToNode(nodeData);
                                    }
                                }
                            }
                        });
                    });
                    
                } catch (error) {
                    console.error(`Error updating breadcrumbs: ${error}`);
                }
            }
            
            // Highlight the selected node in the visualization
            highlightSelectedNode(nodeId) {
                // Get the selected node data
                const selectedNodeData = this.graphData.nodes.find(n => n.id === nodeId);
                if (!selectedNodeData) return;
                
                // Build set of connected nodes: selected + parent + children
                const connectedNodeIds = new Set([nodeId]);
                
                // Add parent if exists
                if (selectedNodeData.parent) {
                    connectedNodeIds.add(selectedNodeData.parent);
                }
                
                // Add all children
                this.graphData.nodes.forEach(node => {
                    if (node.parent === nodeId) {
                        connectedNodeIds.add(node.id);
                    }
                });
                
                // Apply dimming to all nodes based on whether they're connected
                this.nodes.forEach((nodeMesh, id) => {
                    // Skip if this is an instanced node
                    if (nodeMesh.isInstancedNode) return;
                    
                    const nodeData = this.graphData.nodes.find(n => n.id === id);
                    if (nodeData && nodeMesh.material) {
                        const color = this.getNodeColor(nodeData.type);
                        
                        if (connectedNodeIds.has(id)) {
                            // Connected nodes: keep them visible but not as bright as selected
                            nodeMesh.material.color.set(color);
                            if (nodeMesh.material.emissive) {
                                nodeMesh.material.emissive.setScalar(0.15);
                                nodeMesh.material.emissiveIntensity = 0.3;
                            }
                            nodeMesh.scale.set(1, 1, 1);
                        } else {
                            // Unconnected nodes: dim them significantly
                            // Darken the color
                            const dimmedColor = new THREE.Color(color).multiplyScalar(0.3);
                            nodeMesh.material.color.set(dimmedColor);
                            if (nodeMesh.material.emissive) {
                                nodeMesh.material.emissive.setScalar(0.01);
                                nodeMesh.material.emissiveIntensity = 0.05;
                            }
                            nodeMesh.scale.set(0.8, 0.8, 0.8);
                        }
                    }
                });
                
                // Dim all links first, but check if they connect to valid nodes
                this.links.forEach((linkMesh, linkId) => {
                    if (linkMesh.material) {
                        const userData = linkMesh.userData;
                        const sourceId = userData.source;
                        const targetId = userData.target;
                        
                        // Check if both source and target nodes actually exist in the current node set
                        const sourceExists = this.nodes.has(sourceId);
                        const targetExists = this.nodes.has(targetId);
                        
                        if (!sourceExists || !targetExists) {
                            // Hide orphaned links completely
                            linkMesh.visible = false;
                            console.log(`Hiding orphaned link: ${sourceId} -> ${targetId} (source exists: ${sourceExists}, target exists: ${targetExists})`);
                        } else {
                            // Ensure link is visible and dim it
                            linkMesh.visible = true;
                            // Store original opacity if not stored
                            if (!linkMesh.material.userData.dimmedOpacity) {
                                linkMesh.material.userData.dimmedOpacity = true;
                            }
                            // Dim all links significantly
                            linkMesh.material.opacity = 0.02;
                        }
                    }
                });
                
                // Reset all link highlights first
                this.resetLinkHighlights();
                
                // Highlight the selected node specifically
                const selectedNode = this.nodes.get(nodeId);
                if (selectedNode && !selectedNode.isInstancedNode && selectedNode.material) {
                    // Make selected node very bright
                    selectedNode.material.color.set(0xFFFFFF);
                    if (selectedNode.material.emissive) {
                        selectedNode.material.emissive.setScalar(0.5);
                        selectedNode.material.emissiveIntensity = 1.0;
                    }
                    selectedNode.scale.set(1.3, 1.3, 1.3);
                }
                
                // Highlight connected links
                this.highlightConnectedLinks(nodeId);
            }
            
            // Highlight all links connected to the specified node
            highlightConnectedLinks(nodeId) {
                // Get the selected node data
                const selectedNodeData = this.graphData.nodes.find(n => n.id === nodeId);
                if (!selectedNodeData) return;
                
                // Build set of connected nodes: selected + parent + children
                const connectedNodeIds = new Set([nodeId]);
                
                // Add parent if exists
                if (selectedNodeData.parent) {
                    connectedNodeIds.add(selectedNodeData.parent);
                }
                
                // Add all children
                this.graphData.nodes.forEach(node => {
                    if (node.parent === nodeId) {
                        connectedNodeIds.add(node.id);
                    }
                });
                
                // Highlight links between selected node and its parent/children
                this.links.forEach((linkMesh, linkId) => {
                    const userData = linkMesh.userData;
                    if (!userData || !linkMesh.material) return;
                    
                    const sourceId = userData.source;
                    const targetId = userData.target;
                    
                    // First check if both nodes exist in the current node set
                    const sourceExists = this.nodes.has(sourceId);
                    const targetExists = this.nodes.has(targetId);
                    
                    if (!sourceExists || !targetExists) {
                        // Skip orphaned links
                        linkMesh.visible = false;
                        return;
                    }
                    
                    // Check if this link connects the selected node with its parent or children
                    const isParentChildLink = 
                        (sourceId === nodeId && connectedNodeIds.has(targetId)) ||
                        (targetId === nodeId && connectedNodeIds.has(sourceId));
                    
                    if (isParentChildLink) {
                        // Make sure link is visible
                        linkMesh.visible = true;
                        
                        // Apply electrified blue highlighting
                        linkMesh.material.color.set(0x1e90ff); // Dodger blue
                        linkMesh.material.opacity = 1.0; // Full opacity
                        linkMesh.material.linewidth = 4; // Thicker line
                        
                        // Store animation data for pulsing effect
                        linkMesh.userData.highlightStartTime = Date.now();
                        linkMesh.userData.highlighted = true;
                        
                        // Add to highlighted links set
                        if (!this.highlightedLinks) {
                            this.highlightedLinks = new Set();
                        }
                        this.highlightedLinks.add(linkMesh);
                        
                        console.log(`Highlighted link: ${sourceId} -> ${targetId}`);
                    }
                });
            }
            
            // Reset all link highlights to their original appearance
            resetLinkHighlights() {
                // Clear highlighted links set
                if (this.highlightedLinks) {
                    this.highlightedLinks.clear();
                }
                
                // Reset all links to their original appearance
                this.links.forEach((linkMesh, linkId) => {
                    const userData = linkMesh.userData;
                    if (userData && userData.highlighted && linkMesh.material) {
                        // Use stored original properties from material.userData
                        const materialData = linkMesh.material.userData;
                        if (materialData) {
                            linkMesh.material.color.set(materialData.originalColor);
                            linkMesh.material.opacity = materialData.originalOpacity;
                            linkMesh.material.linewidth = materialData.originalLineWidth;
                        }
                        
                        // Remove highlight flags
                        userData.highlighted = false;
                        delete userData.highlightStartTime;
                    }
                });
            }
            
            

            
            // Ensure a node and its parents are visible (expanded)
            ensureNodeVisible(nodeData) {
                if (!nodeData || !nodeData.parent) return;
                
                console.log(`Ensuring node ${nodeData.id} with parent ${nodeData.parent} is visible`);
                
                // Check if parent exists and add to expanded nodes
                const parentId = nodeData.parent;
                if (parentId && !this.expandedNodes.has(parentId)) {
                    console.log(`Adding parent ${parentId} to expanded nodes`);
                    
                    // Add parent to expanded nodes
                    this.expandedNodes.add(parentId);
                    
                    // Get parent node data
                    const parentNode = this.graphData.nodes.find(n => n.id === parentId);
                    if (parentNode) {
                        // Recursively expand parent's parents if needed
                        this.ensureNodeVisible(parentNode);
                    }
                }
            }
            
            // Navigate to a specific node in the visualization
            navigateToNode(nodeData) {
                if (!nodeData) return;
                
                console.log(`Navigating to node: ${nodeData.name} (${nodeData.id})`);
                
                // Make sure node and its parents are visible (expanded)
                if (nodeData.parent) {
                    this.ensureNodeVisible(nodeData);
                }
                
                // If this node has children but isn't expanded, expand it
                if (!this.expandedNodes.has(nodeData.id)) {
                    console.log(`Expanding node ${nodeData.id}`);
                    this.expandedNodes.add(nodeData.id);
                    
                    // Update the visualization with newly expanded node
                    const visibleNodes = this.getVisibleNodes();
                    this.positionNodes(visibleNodes);
                    this.createNodeObjects(visibleNodes);
                    this.createLinkObjects(this.getVisibleLinks(visibleNodes));
                    this.setupNodeAnimations(visibleNodes);
                }
                
                // Select the node to show details
                this.selectNode(nodeData);
                
                // Get position from nodePositions
                const position = this.nodePositions.get(nodeData.id);
                if (position) {
                    this.navigateToPosition(position.x, position.y, position.z);
                } else {
                    console.warn(`Position not found for node ${nodeData.id}`);
                }
            }
            
            // Navigate camera to a specific position
            navigateToPosition(x, y, z) {
                // For performance, use instant camera movement instead of animation
                const target = new THREE.Vector3(x, y, z);
                const distance = 200; // Distance from target
                
                // Calculate new camera position (slightly offset from target)
                const newPosition = new THREE.Vector3(
                    x + distance,
                    y + distance * 0.5,
                    z + distance
                );
                
                // Instant camera positioning for maximum performance
                this.camera.position.set(newPosition.x, newPosition.y, newPosition.z);
                this.controls.target.set(x, y, z);
                this.controls.update();
                this.cameraControlsNeedUpdate = true;
            }
            
            // Animation loop with performance optimizations
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Skip rendering if the visualization isn't active
                if (!this.isActive) return;
                
                const time = performance.now() * 0.001; // Convert to seconds
                
                // Calculate delta time for smooth rotation
                if (!this.lastFrameTime) {
                    this.lastFrameTime = time;
                }
                const deltaTime = time - this.lastFrameTime;
                this.lastFrameTime = time;
                
                // Update TWEEN animations
                TWEEN.update();
                
                // Handle scene rotation if enabled
                if (this.isRotating) {
                    // Rotate the entire scene around the Y-axis (vertical axis) at a significant speed
                    const rotationSpeed = 0.5; // Radians per second - quite fast for visual appeal
                    this.scene.rotation.y += rotationSpeed * deltaTime; // Use actual delta time for consistent speed
                }
                
                // Update camera controls - only when needed
                if (this.controls && this.cameraControlsNeedUpdate) {
                    this.controls.update();
                    this.cameraControlsNeedUpdate = false;
                }
                
                // Performance optimization: Check if we need to perform updates this frame
                const now = performance.now();
                const nodeCount = this.nodes.size;
                
                // Calculate update frequency based on node count - fewer updates for more nodes
                let updateInterval = 16; // 60fps for small numbers of nodes
                
                if (nodeCount > 100) updateInterval = 33;      // 30fps for moderate nodes
                if (nodeCount > 300) updateInterval = 50;      // 20fps for lots of nodes
                if (nodeCount > 600) updateInterval = 100;     // 10fps for huge numbers of nodes
                if (nodeCount > 1000) updateInterval = 200;    // 5fps for extreme numbers of nodes
                
                // Only update if enough time has passed
                if (!this._lastAnimationUpdate || now - this._lastAnimationUpdate > updateInterval) {
                    this._lastAnimationUpdate = now;
                    
                    // Detect if we have too many nodes and temporarily disable animations
                    const animationsDisabled = nodeCount > 1000;
                    
                    // Update node animations if not disabled
                    if (!animationsDisabled) {
                        this.updateNodeAnimations(time);
                    }
                    
                    // Update highlighted link animations for electrified effect
                    this.updateHighlightedLinkAnimations();
                    
                    // Only update links infrequently for better performance - frequency based on node count
                    if (!this._linkUpdateCounter) this._linkUpdateCounter = 0;
                    this._linkUpdateCounter++;
                    
                    const linkUpdateThreshold = nodeCount > 300 ? 10 : (nodeCount > 100 ? 5 : 3);
                    
                    if (this._linkUpdateCounter >= linkUpdateThreshold) {
                        this._linkUpdateCounter = 0;
                        
                        // Optimize link updates - don't update every single link when we have many nodes
                        if (nodeCount > 500) {
                            this.updateCriticalLinkPositions(); // Only update important links
                        } else {
                            this.updateLinkPositions();
                        }
                    }
                }
                
                // Render the scene
                this.renderer.render(this.scene, this.camera);
            }
            
            // For large node counts, only update the most important links
            updateCriticalLinkPositions() {
                // Get the visible nodes close to the camera
                const cameraPos = this.camera.position;
                const visibleLinks = Array.from(this.links.values())
                    .filter(link => {
                        const sourceNode = this.nodes.get(link.userData.source);
                        const targetNode = this.nodes.get(link.userData.target);
                        
                        if (!sourceNode || !targetNode) return false;
                        
                        // Calculate distance to camera
                        const avgPos = new THREE.Vector3()
                            .addVectors(sourceNode.position, targetNode.position)
                            .multiplyScalar(0.5);
                            
                        const distToCamera = avgPos.distanceTo(cameraPos);
                        
                        // Only update links that are close to the camera or have moved significantly
                        return distToCamera < 500;
                    });
                
                // Only update a subset of links each frame for better performance
                const linksToUpdate = visibleLinks.slice(0, 100); // Limit to 100 links per update
                
                // Update only these critical links
                for (const link of linksToUpdate) {
                    const { source: sourceId, target: targetId } = link.userData;
                    
                    const sourceNode = this.nodes.get(sourceId);
                    const targetNode = this.nodes.get(targetId);
                    
                    if (!sourceNode || !targetNode) continue;
                    
                    const sourcePos = sourceNode.position.clone();
                    const targetPos = targetNode.position.clone();
                    
                    // Simple and fast - just update endpoints for most links
                    const points = [sourcePos, targetPos];
                    link.geometry.setFromPoints(points);
                    link.geometry.attributes.position.needsUpdate = true;
                }
            }
            
            // Window resize handler
            onWindowResize() {
                // Get the actual container bounds
                const rect = this.container.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                
                // Update camera aspect ratio
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                
                // Update renderer size
                this.renderer.setSize(width, height);
                
                console.log(`Renderer resized to: ${width}x${height}`);
            }
            
            setupNodeOrbits(nodes) {
                // Create orbital patterns for nodes
                this.nodeOrbits = new Map();
                
                // Setup animations for nodes (which replaces the orbits concept)
                this.setupNodeAnimations(nodes);
            }
            
            setupNodeAnimations(nodes) {
                // Create animation data for nodes
                this.nodeAnimations = new Map();
                
                nodes.forEach(node => {
                    // Skip animations for certain node types
                    if (node.level === 0) return; // Don't animate root
                    
                    // Create animation parameters based on node type and level
                    const amplitude = Math.max(0.5, 5 - node.level * 0.5); // Higher levels have smaller movement
                    const speed = 0.2 + Math.random() * 0.3; // Random speed for natural movement
                    const phase = Math.random() * Math.PI * 2; // Random starting phase
                    const direction = new THREE.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ).normalize();
                    
                    this.nodeAnimations.set(node.id, {
                        originalPosition: this.nodePositions.get(node.id) 
                            ? { ...this.nodePositions.get(node.id) } 
                            : { x: 0, y: 0, z: 0 },
                        amplitude,
                        speed,
                        phase,
                        direction
                    });
                });
            }
            
            updateNodeAnimations(time) {
                // If no nodes should be animated, return
                if (!this.nodeAnimations || this.nodeAnimations.size === 0) return;
                
                // Update positions for animated nodes
                this.nodeAnimations.forEach((animation, nodeId) => {
                    const nodeMesh = this.nodes.get(nodeId);
                    if (!nodeMesh) return;
                    
                    const { originalPosition, amplitude, speed, phase, direction } = animation;
                    
                    // Calculate oscillation factor
                    const oscillation = amplitude * Math.sin(time * speed + phase);
                    
                    // Apply movement in the node's assigned direction while preserving original position
                    nodeMesh.position.x = originalPosition.x + direction.x * oscillation;
                    nodeMesh.position.y = originalPosition.y + direction.y * oscillation;
                    nodeMesh.position.z = originalPosition.z + direction.z * oscillation;
                    
                    // Update any connected links if needed
                    // We don't need to update link positions because they use the node mesh positions directly
                });
                
                // Update link positions that involve animated nodes
                // This should ensure links properly follow the animated nodes
                this.links.forEach(link => {
                    const sourceId = link.userData.source;
                    const targetId = link.userData.target;
                    
                    // Skip if this isn't a curved link (those need geometry updates)
                    if (link.geometry.type !== 'BufferGeometry') return;
                    
                    // Only update if source or target is being animated
                    if (!this.nodeAnimations.has(sourceId) && !this.nodeAnimations.has(targetId)) return;
                    
                    const sourceNode = this.nodes.get(sourceId);
                    const targetNode = this.nodes.get(targetId);
                    
                    if (!sourceNode || !targetNode) return;
                    
                    // For straight lines, just update the points
                    if (link.geometry.attributes.position.count <= 2) {
                        const points = [sourceNode.position, targetNode.position];
                        link.geometry.setFromPoints(points);
                    } else {
                        // For curved lines, regenerate the curve with the current positions
                        const sourcePos = sourceNode.position.clone();
                        const targetPos = targetNode.position.clone();
                        const distance = sourcePos.distanceTo(targetPos);
                        
                        // Only recreate the curve if it's a longer distance
                        if (distance >= 50) {
                            const midPoint = sourcePos.clone().add(targetPos).multiplyScalar(0.5);
                            const lineDirection = targetPos.clone().sub(sourcePos).normalize();
                            
                            // Create perpendicular direction
                            const perpendicular = new THREE.Vector3(
                                -lineDirection.z,
                                lineDirection.y,
                                lineDirection.x
                            ).normalize();
                            
                            // Curve height based on distance
                            const curveHeight = Math.min(distance * 0.2, 50);
                            
                            // Control point
                            const controlPoint = midPoint.clone().add(
                                perpendicular.clone().multiplyScalar(curveHeight)
                            );
                            
                            // Create new curve
                            const curve = new THREE.QuadraticBezierCurve3(
                                sourcePos,
                                controlPoint,
                                targetPos
                            );
                            
                            // Sample points along curve
                            const points = curve.getPoints(20);
                            link.geometry.setFromPoints(points);
                        }
                    }
                    
                    // Mark geometry as needing update
                    link.geometry.attributes.position.needsUpdate = true;
                });
            }
            
            // Update animations for highlighted links to create electrified effect
            updateHighlightedLinkAnimations() {
                if (!this.highlightedLinks || this.highlightedLinks.size === 0) return;
                
                const currentTime = Date.now();
                
                this.highlightedLinks.forEach(linkMesh => {
                    const userData = linkMesh.userData;
                    if (userData && userData.highlighted && userData.highlightStartTime) {
                        const elapsed = (currentTime - userData.highlightStartTime) / 1000; // Convert to seconds
                        
                        // Create pulsing effect with sine wave
                        const pulseIntensity = 0.3 + 0.4 * Math.sin(elapsed * 4); // Pulse between 0.3 and 0.7
                        const colorIntensity = 0.6 + 0.4 * Math.sin(elapsed * 6); // Different frequency for color
                        
                        // Animate opacity for pulsing effect
                        linkMesh.material.opacity = 0.7 + 0.3 * pulseIntensity;
                        
                        // Animate color for electrified effect (blue variations)
                        const baseBlue = 0x1e90ff;
                        const r = (baseBlue >> 16) & 0xff;
                        const g = (baseBlue >> 8) & 0xff;
                        const b = baseBlue & 0xff;
                        
                        // Add some electric white/cyan tint
                        const electricR = Math.min(255, r + Math.floor(100 * colorIntensity));
                        const electricG = Math.min(255, g + Math.floor(150 * colorIntensity));
                        const electricB = Math.min(255, b + Math.floor(50 * colorIntensity));
                        
                        const electricColor = (electricR << 16) | (electricG << 8) | electricB;
                        linkMesh.material.color.setHex(electricColor);
                    }
                });
            }
            
            updateLinkPositions() {
                for (const [id, link] of this.links.entries()) {
                    const { source: sourceId, target: targetId } = link.userData;
                    
                    const sourceNode = this.nodes.get(sourceId);
                    const targetNode = this.nodes.get(targetId);
                    
                    if (!sourceNode || !targetNode) continue;
                    
                    const sourcePos = sourceNode.position.clone();
                    const targetPos = targetNode.position.clone();
                    const distance = sourcePos.distanceTo(targetPos);
                    
                    // Use curved links for longer distances
                    if (distance >= 50 && link.geometry.type === 'BufferGeometry') {
                        // Create a curved link using a bezier curve
                        const midPoint = new THREE.Vector3().addVectors(sourcePos, targetPos).multiplyScalar(0.5);
                        const lineDirection = new THREE.Vector3().subVectors(targetPos, sourcePos).normalize();
                        
                        // Create a perpendicular direction for the control point
                        const perpendicular = new THREE.Vector3(
                            -lineDirection.z,
                            lineDirection.y,
                            lineDirection.x
                        ).normalize();
                        
                        // Set curve height based on distance
                        const curveHeight = Math.min(distance * 0.2, 50);
                        
                        // Create control point
                        const controlPoint = midPoint.clone().add(
                            perpendicular.clone().multiplyScalar(curveHeight)
                        );
                        
                        // Create quadratic bezier curve
                        const curve = new THREE.QuadraticBezierCurve3(
                            sourcePos,
                            controlPoint,
                            targetPos
                        );
                        
                        // Set geometry from curve points
                        const points = curve.getPoints(20);
                        link.geometry.setFromPoints(points);
                    } else {
                        // Create straight line for shorter distances
                        const points = [sourcePos, targetPos];
                        link.geometry.setFromPoints(points);
                    }
                    
                    // Mark geometry as needing update
                    link.geometry.attributes.position.needsUpdate = true;
                }
            }
            
            // Animate the camera to focus on a specific position
            animateCameraToPosition(position) {
                if (!position) return;
                
                // Get current camera position
                const currentPosition = this.camera.position.clone();
                
                // Calculate target position - back away from the node a bit
                const targetPosition = position.clone();
                targetPosition.z += 300; // Move back to see the node
                
                // Setup the animation with TWEEN
                new TWEEN.Tween(currentPosition)
                    .to(targetPosition, 800)
                    .easing(TWEEN.Easing.Cubic.InOut)
                    .onUpdate(() => {
                        // Update camera position during animation
                        this.camera.position.copy(currentPosition);
                        // Make camera look at the node
                        this.camera.lookAt(position);
                    })
                    .start();
                
                // Also animate the lookAt point
                const currentLookAt = new THREE.Vector3(0, 0, 0);
                new TWEEN.Tween(currentLookAt)
                    .to(position, 800)
                    .easing(TWEEN.Easing.Cubic.InOut)
                    .onUpdate(() => {
                        this.camera.lookAt(currentLookAt);
                    })
                    .start();
            }
            
            // Navigate back in history
            navigateBack() {
                console.log("Navigating back in history");
                
                // Check if we can navigate back
                if (this.currentNodeIndex <= 0) {
                    console.log("No previous node in history");
                    return;
                }
                
                // Get the previous node ID
                this.currentNodeIndex--;
                const previousNodeId = this.navigationHistory[this.currentNodeIndex];
                
                // Set flag to indicate we're navigating through history
                this._isHistoryNavigation = true;
                
                // Find the node data for the previous node
                const nodeData = this.graphData.nodes.find(n => n.id === previousNodeId);
                if (nodeData) {
                    // Navigate to the previous node
                    console.log(`Going back to: ${nodeData.name} (${nodeData.id})`);
                    this.selectNode(nodeData);
                } else {
                    console.error(`Node with ID ${previousNodeId} not found in graph data`);
                }
                
                // Update back button visibility based on new history position
                this.updateBackButtonVisibility();
            }
            
            // Update back button visibility based on history state
            updateBackButtonVisibility() {
                const backButton = document.getElementById('back-button');
                if (!backButton) return;
                
                // Only show back button if we have history to go back to
                if (this.currentNodeIndex > 0) {
                    backButton.classList.remove('hidden');
                } else {
                    backButton.classList.add('hidden');
                }
            }
            
            // Helper method to fetch node details directly from API
            async fetchNodeDetails(nodeId) {
                try {
                    console.log(`Fetching details for node: ${nodeId}`);
                    const response = await fetch(`/api/details/${nodeId}`);
                    
                    if (!response.ok) {
                        console.error(`Error fetching node details: ${response.status} ${response.statusText}`);
                        return null;
                    }
                    
                    const data = await response.json();
                    console.log(`Successfully fetched details for node: ${nodeId}`);
                    return data;
                } catch (error) {
                    console.error(`Error fetching node details: ${error}`);
                    return null;
                }
            }
            
            // Toggle the details panel visibility
            toggleDetailsPanel() {
                const detailsPanel = document.getElementById('details-panel');
                const container = document.querySelector('.container');
                const toggleButton = document.getElementById('toggle-panel');
                
                if (!detailsPanel || !container || !toggleButton) return;
                
                // Mark as first-clicked to permanently disable rotation
                if (!toggleButton.classList.contains('first-clicked')) {
                    toggleButton.classList.add('first-clicked');
                    console.log("Info button marked as first-clicked - rotation permanently disabled");
                }
                
                // Check current state
                const isHidden = detailsPanel.classList.contains('hidden');
                
                if (isHidden) {
                    // Show the panel
                    detailsPanel.classList.remove('hidden');
                    container.classList.remove('panel-hidden');
                    toggleButton.textContent = 'Info';
                    
                    // Add panel-open class to stop electrical animation
                    toggleButton.classList.add('panel-open');
                    
                    console.log("Details panel shown");
                    
                    // Display either selected node info or default info page
                    this.updatePanelWithSelectedNode();
                } else {
                    // Hide the panel
                    detailsPanel.classList.add('hidden');
                    container.classList.add('panel-hidden');
                    toggleButton.textContent = 'Info';
                    
                    // Remove panel-open class to restart electrical animation (but keep first-clicked)
                    toggleButton.classList.remove('panel-open');
                    
                    console.log("Details panel hidden");
                }
                
                // Trigger window resize to update renderer size
                setTimeout(() => {
                    this.onWindowResize();
                    // Force a render to ensure visual update
                    if (this.renderer && this.scene && this.camera) {
                        this.renderer.render(this.scene, this.camera);
                    }
                }, 100);
            }
            
            toggleLegend() {
                const legendPanel = document.getElementById('legend-panel');
                const toggleButton = document.getElementById('toggle-legend');
                
                if (!legendPanel || !toggleButton) return;
                
                // Check current state
                const isHidden = legendPanel.classList.contains('hidden');
                
                if (isHidden) {
                    // Show the legend
                    legendPanel.classList.remove('hidden');
                    console.log("Legend panel shown");
                } else {
                    // Hide the legend
                    legendPanel.classList.add('hidden');
                    console.log("Legend panel hidden");
                }
            }
            
            toggleHelp() {
                const helpPanel = document.getElementById('help-panel');
                const toggleButton = document.getElementById('toggle-help');
                
                if (!helpPanel || !toggleButton) return;
                
                // Check current state
                const isHidden = helpPanel.classList.contains('hidden');
                
                if (isHidden) {
                    // Show the help panel
                    helpPanel.classList.remove('hidden');
                    console.log("Help panel shown");
                } else {
                    // Hide the help panel
                    helpPanel.classList.add('hidden');
                    console.log("Help panel hidden");
                }
            }
            
            // Initialize panel as hidden
            initializePanelState() {
                const detailsPanel = document.getElementById('details-panel');
                const container = document.querySelector('.container');
                const legendPanel = document.getElementById('legend-panel');
                const helpPanel = document.getElementById('help-panel');
                
                if (detailsPanel && container) {
                    detailsPanel.classList.add('hidden');
                    container.classList.add('panel-hidden');
                    console.log("Details panel initialized as hidden");
                    
                    // Force a resize to ensure renderer matches the new container dimensions
                    setTimeout(() => {
                        this.onWindowResize();
                    }, 100);
                }
                
                // Initialize legend as hidden
                if (legendPanel) {
                    legendPanel.classList.add('hidden');
                    console.log("Legend panel initialized as hidden");
                }
                
                // Initialize help panel as hidden
                if (helpPanel) {
                    helpPanel.classList.add('hidden');
                    console.log("Help panel initialized as hidden");
                }
            }
            
            // Update panel with currently selected node information or default info
            async updatePanelWithSelectedNode() {
                const detailsContent = document.getElementById('details-content');
                
                if (!detailsContent) return;
                
                if (!this.selectedNode) {
                    // Show default information page when no node is selected
                    this.displayDefaultInfoPage();
                    return;
                }
                
                // Title now handled by cosmic node title in renderer
                
                // Show loading indicator
                detailsContent.innerHTML = `
                    <div class="loading-indicator">
                        <div class="spinner"></div>
                        <span>Loading details...</span>
                    </div>
                `;
                
                try {
                    // Try to get complete node data
                    const fullNodeData = await this.findNodeInBackendData(this.selectedNode.id);
                    
                    if (fullNodeData) {
                        // Display the complete node details
                        this.displayNodeDetails(fullNodeData);
                        
                        // Update breadcrumbs
                        this.updateBreadcrumbs(this.selectedNode.id);
                        
                        // Restore scroll position if available
                        if (this.scrollPositions.has(this.selectedNode.id)) {
                            const scrollContainer = document.querySelector('.single-scrollable-container');
                            if (scrollContainer) {
                                setTimeout(() => {
                                    scrollContainer.scrollTop = this.scrollPositions.get(this.selectedNode.id);
                                }, 100);
                            }
                        } else {
                            // Scroll to top for new display
                            const scrollContainer = document.querySelector('.single-scrollable-container');
                            if (scrollContainer) {
                                scrollContainer.scrollTop = 0;
                            }
                        }
                    } else {
                        // If API fetch fails, use the basic node data we have
                        this.displayNodeDetails(this.selectedNode);
                    }
                } catch (error) {
                    console.error(`Error fetching node details: ${error}`);
                    // Fall back to basic data
                    this.displayNodeDetails(this.selectedNode);
                }
            }
            
            // Display default information page when no node is selected
            displayDefaultInfoPage() {
                const detailsContent = document.getElementById('details-content');
                const breadcrumbContainer = document.querySelector('.breadcrumb-container');
                
                if (!detailsContent) return;
                
                // Set "About" breadcrumb for default info page
                if (breadcrumbContainer) {
                    breadcrumbContainer.innerHTML = '<div class="breadcrumb-item">About</div>';
                }
                
                // Create default information content
                const defaultContent = `
                    <!-- Mobile-only title section that's part of scrollable content -->
                    <div class="mobile-title-section">
                        <div class="mobile-cosmic-title">
                            <h2>AI Alignment Space</h2>
                            <div class="mobile-subtitle">An Artistic Exploration of Automated Conceptual Co-Creation</div>
                        </div>
                        <div class="mobile-orbital-decoration">
                            <div class="orbit-ring"></div>
                            <div class="orbit-ring orbit-ring-2"></div>
                            <div class="orbit-ring orbit-ring-3"></div>
                        </div>
                    </div>
                    
                    <div class="detail-section featured-section">
                        <div class="section-header">
                            <h3>Conceptual Co-Creation Framework</h3>
                        </div>
                        <div class="section-content">
                            <div class="highlight-box">
                                <p>This visualization serves as an <strong>exploration basis</strong> for how automated conceptual co-created work on AI alignment could manifest. It represents a pioneering approach where artificial intelligence generates comprehensive knowledge structures while maintaining human guidance and editorial oversight.</p>
                            </div>
                            
                            <div class="methodology-grid">
                                <div class="method-card">
                                    <h4>AI-Generated Content</h4>
                                    <p>All node content is entirely AI-created, demonstrating the potential for automated knowledge synthesis and conceptual mapping.</p>
                                </div>
                                <div class="method-card">
                                    <h4>Human-Guided Framework</h4>
                                    <p>Based on human-authored and edited foundational papers, ensuring meaningful direction and quality control.</p>
                                </div>
                                <div class="method-card">
                                    <h4>Holistic Integration</h4>
                                    <p>AI alignment serves as one component within a larger interdisciplinary framework prioritizing human and ecological centeredness.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="detail-section artistic-section">
                        <div class="section-header">
                            <h3>Artistic & Philosophical Dimensions</h3>
                        </div>
                        <div class="section-content">
                            <div class="philosophy-container">
                                <div class="cosmic-metaphor">
                                    <h4>The Celestial Metaphor</h4>
                                    <p>The spherical, orbital aesthetic represents a profound duality: <em>inorganic structures housing organic meaning</em>. Like planets and stars in space, these digital orbs contain the essence of human knowledge and values within technological frameworks.</p>
                                </div>
                                
                                <div class="design-rationale">
                                    <h4>Design Philosophy</h4>
                                    <p>This is not an actual universe, but a <strong>human-created mirror</strong> of cosmic organization. The spherical nodes embody the paradox of our technological age: inorganic information systems that organic humans must navigate, interpret, and apply to preserve what is fundamentally human and ecological.</p>
                                </div>
                                
                                <div class="artistic-insights">
                                    <h4>Emergent Beauty in AI Collaboration</h4>
                                    <p>From an artistic perspective, this work demonstrates how AI can serve as a creative partner in knowledge visualization. The organic emergence of conceptual relationships through algorithmic processing creates unexpected aesthetic patterns that mirror natural systems while serving human understanding.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="detail-section node-types-section">
                        <div class="section-header">
                            <h3>Node Types & Hierarchy</h3>
                        </div>
                        <div class="section-content">
                            <div class="highlight-box">
                                <p>The visualization employs a structured hierarchy of node types, each serving a specific purpose in the conceptual architecture. This systematic approach enables clear organization and facilitates technical compatibility across different knowledge domains.</p>
                            </div>
                            
                            <div class="methodology-grid">
                                <div class="method-card">
                                    <h4><span class="legend-color component-group" style="display: inline-block; width: 12px; height: 12px; margin-right: 8px; vertical-align: middle;"></span>Component Group</h4>
                                    <p>Highest-level organizational units that group related components together. These represent major conceptual domains or thematic areas within the knowledge structure.</p>
                                </div>
                                
                                <div class="method-card">
                                    <h4><span class="legend-color component" style="display: inline-block; width: 12px; height: 12px; margin-right: 8px; vertical-align: middle;"></span>Component</h4>
                                    <p>Primary functional units within component groups. Components represent distinct areas of focus or major functional blocks that can operate semi-independently.</p>
                                </div>
                                
                                <div class="method-card">
                                    <h4><span class="legend-color subcomponent" style="display: inline-block; width: 12px; height: 12px; margin-right: 8px; vertical-align: middle;"></span>Subcomponent</h4>
                                    <p>Specialized divisions within components that handle specific aspects or sub-domains. These provide more granular organization while maintaining connection to the parent component.</p>
                                </div>
                                
                                <div class="method-card">
                                    <h4><span class="legend-color capability" style="display: inline-block; width: 12px; height: 12px; margin-right: 8px; vertical-align: middle;"></span>Capability</h4>
                                    <p>High-level functional abilities that enable specific competencies within subcomponents. Capabilities group related functions and define what the system can accomplish through coordinated operations.</p>
                                </div>
                                
                                <div class="method-card">
                                    <h4><span class="legend-color function" style="display: inline-block; width: 12px; height: 12px; margin-right: 8px; vertical-align: middle;"></span>Function</h4>
                                    <p>Specific operational processes or procedures that perform defined tasks. Functions are the active elements that transform inputs into outputs through systematic operations.</p>
                                </div>
                                
                                <div class="method-card">
                                    <h4><span class="legend-color specification" style="display: inline-block; width: 12px; height: 12px; margin-right: 8px; vertical-align: middle;"></span>Specification</h4>
                                    <p>Technical requirements and standards that define how functions should be implemented. Specifications include detailed requirements, constraints, and formal properties needed for system implementation.</p>
                                </div>
                                
                                <div class="method-card">
                                    <h4><span class="legend-color integration" style="display: inline-block; width: 12px; height: 12px; margin-right: 8px; vertical-align: middle;"></span>Integration</h4>
                                    <p>Implementation approaches and coordination mechanisms that enable specifications to be realized in practice. Integrations define how different system elements connect and work together.</p>
                                </div>
                                
                                <div class="method-card">
                                    <h4><span class="legend-color technique" style="display: inline-block; width: 12px; height: 12px; margin-right: 8px; vertical-align: middle;"></span>Technique</h4>
                                    <p>Specific methodological approaches and algorithms used within integrations. Techniques provide the concrete methods and strategies for implementing system functionality.</p>
                                </div>
                                
                                <div class="method-card">
                                    <h4><span class="legend-color application" style="display: inline-block; width: 12px; height: 12px; margin-right: 8px; vertical-align: middle;"></span>Application</h4>
                                    <p>Practical implementations or use cases where the system's capabilities are applied to real-world scenarios. Applications bridge theory and practice.</p>
                                </div>
                                
                                <div class="method-card">
                                    <h4><span class="legend-color input" style="display: inline-block; width: 12px; height: 12px; margin-right: 8px; vertical-align: middle;"></span>Input</h4>
                                    <p>Data, information, or resources that enter the system or function. Inputs represent the raw materials or information that functions process and transform.</p>
                                </div>
                                
                                <div class="method-card">
                                    <h4><span class="legend-color output" style="display: inline-block; width: 12px; height: 12px; margin-right: 8px; vertical-align: middle;"></span>Output</h4>
                                    <p>Results, products, or information that emerge from system processes. Outputs represent the value created through the transformation of inputs by functions.</p>
                                </div>
                            </div>
                            
                            <div class="cosmic-metaphor" style="margin-top: 25px;">
                                <h4>Hierarchical Flow</h4>
                                <p>The progression from <strong>Component Group → Component → Subcomponent → Capability → Function → Specification</strong> creates a natural decomposition that facilitates both human understanding and technical implementation. <strong>Inputs</strong> and <strong>Outputs</strong> define the interfaces, while <strong>Techniques</strong>, <strong>Integrations</strong>, and <strong>Applications</strong> provide the practical implementation details.</p>
                            </div>
                        </div>
                    </div>

                    <div class="detail-section interaction-section">
                        <div class="section-header">
                            <h3>Navigation & Exploration</h3>
                        </div>
                        <div class="section-content">
                            <div class="interaction-guide">
                                <div class="control-group">
                                    <h4>Mouse Interactions</h4>
                                    <ul class="styled-list">
                                        <li><span class="action">Click nodes</span> to dive into detailed conceptual explorations</li>
                                        <li><span class="action">Click empty space</span> to deselect nodes and return to this overview</li>
                                        <li><span class="action">Hover</span> to preview node relationships and types</li>
                                        <li><span class="action">Drag</span> to rotate and explore the sphere from different angles</li>
                                    </ul>
                                </div>
                                
                                <div class="control-group">
                                    <h4>Control Panel</h4>
                                    <ul class="styled-list">
                                        <li><span class="action">Zoom In/Out</span> to focus on specific orbital regions</li>
                                        <li><span class="action">Reset View</span> to return to the cosmic overview</li>
                                        <li><span class="action">Expand/Collapse</span> to reveal or hide conceptual hierarchies</li>
                                        <li><span class="action">Toggle Rotation</span> for dynamic or static exploration</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="detail-section roadmap-section">
                        <div class="section-header">
                            <h3>Project Evolution & Future Phases</h3>
                        </div>
                        <div class="section-content">
                            <div class="methodology-grid">
                                <div class="method-card">
                                    <h4>V1: Foundational Skeleton & Artistic Statement</h4>
                                    <div style="color: #4CAF50; font-weight: bold; margin-bottom: 10px;">Active</div>
                                    <p>The current skeleton serves as both an introduction to the conceptual framework and an artistic statement about AI-human collaborative knowledge creation. This phase establishes the foundational structure and demonstrates the visualization methodology.</p>
                                </div>
                                
                                <div class="method-card">
                                    <h4>V2: Content Refinement & Node Interaction</h4>
                                    <div style="color: #2196F3; font-weight: bold; margin-bottom: 10px;">Planned</div>
                                    <p>Collaborative platform for refining the contents of each node and defining how nodes interact with each other. This phase focuses on deepening the conceptual relationships and improving the quality and accuracy of node-level information through community collaboration.</p>
                                </div>
                                
                                <div class="method-card">
                                    <h4>V3: Input/Output Standardization & Modularization</h4>
                                    <div style="color: #FF9800; font-weight: bold; margin-bottom: 10px;">Vision</div>
                                    <p>Compatibilization of inputs and outputs into consistency following specific standards for integrateability and modularization. This phase establishes technical protocols that enable multiple topical spheres to merge and interact seamlessly based on standardized node interfaces.</p>
                                </div>
                                
                                <div class="method-card">
                                    <h4>V4: AI-Integrated Structured Co-Creation</h4>
                                    <div style="color: #9C27B0; font-weight: bold; margin-bottom: 10px;">Future</div>
                                    <p>Integration of AI into the platform to facilitate the standardization and modularization process in a structured manner. AI assists in maintaining consistency and standards while remaining under human guidance through output editorial review and intervention mechanisms.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="detail-section methodology-section">
                        <div class="section-header">
                            <h3>Architectural Methodology & Design Philosophy</h3>
                        </div>
                        <div class="section-content">
                            <div class="philosophy-container">
                                <div class="cosmic-metaphor">
                                    <h4>Component Hierarchy Design</h4>
                                    <p>The progression from <strong>Component Group → Component → Subcomponent → Functions → Inputs/Outputs</strong> was deliberately chosen to facilitate technical architectural compatibility. This hierarchical structure mirrors how complex systems naturally decompose into manageable, interconnected parts.</p>
                                </div>
                                
                                <div class="design-rationale">
                                    <h4>AI-Guided Knowledge Synthesis</h4>
                                    <p>Artificial intelligence excels at synthesizing vast amounts of information into this structured format, identifying patterns and relationships that might escape human observation. The AI serves as a powerful organizational tool, transforming abstract concepts into concrete, navigable architectures.</p>
                                </div>
                                
                                <div class="artistic-insights">
                                    <h4>Human-AI Co-Creation Framework</h4>
                                    <p>While AI provides the synthesis engine, <strong>human intervention and editorial oversight</strong> remain essential. This creates a collaborative dance between artificial efficiency and human wisdom, ensuring that technological capability serves human values and understanding.</p>
                                </div>
                                
                                <div class="cosmic-metaphor">
                                    <h4>Open Source Commons Evolution</h4>
                                    <p>Through open collaboration with other humans in a commons-based approach, we can collectively arrive at large-scale infrastructure that achieves remarkable things. This methodology embraces the principle that knowledge, like natural systems, evolves most beautifully when it grows organically through community contribution.</p>
                                </div>
                                
                                <div class="design-rationale">
                                    <h4>Evolving Cosmic Harmony</h4>
                                    <p>This framework is designed to be <em>evolutionary</em> - much like solar systems that evolve and arrange themselves into perfect patterns of harmony over time. Each component finds its natural place within the larger system, creating emergent beauty and functionality that transcends the sum of its parts.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="detail-section contact-section">
                        <div class="section-header">
                            <h3>Contact & Collaboration</h3>
                        </div>
                        <div class="section-content">
                            <div class="contact-card">
                                <div class="contact-info">
                                    <h4>Project Creator</h4>
                                    <p class="contact-name">Raphael Hulan</p>
                                    <p class="contact-email">
                                        <a href="mailto:ai-alignment-sphere@proton.me">ai-alignment-sphere@proton.me</a>
                                    </p>
                                </div>
                                
                                <div class="collaboration-note">
                                    <h4>Research & Development</h4>
                                    <p>This project represents ongoing research into and application of AI-human collaborative knowledge creation. We welcome discussions about methodology, applications, and the broader implications of automated conceptual frameworks.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="detail-section legal-section">
                        <div class="section-header">
                            <h3>Methodology & Attribution</h3>
                        </div>
                        <div class="section-content">
                            <div class="legal-grid">
                                <div class="legal-item">
                                    <h4>Experimental Nature</h4>
                                    <p>This visualization represents an experimental approach to AI-assisted knowledge mapping. The content reflects current AI capabilities in conceptual synthesis and should be understood as a research artifact.</p>
                                </div>
                                
                                <div class="legal-item">
                                    <h4>Human-Centered Design</h4>
                                    <p>While AI-generated, all content maintains human oversight and editorial guidance, ensuring alignment with human values and ecological consciousness in technology design.</p>
                                </div>
                                
                                <div class="legal-item">
                                    <h4>Open Exploration</h4>
                                    <p>This tool is designed for artistic and fun interaction and at the same time for educational, research, and contemplative purposes. Users are encouraged to engage critically with both the content and the methodology it represents and explore the topic of AI alignment in a playful manner.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="detail-section imprint-section">
                        <div class="section-header">
                            <h3>Imprint</h3>
                        </div>
                        <div class="section-content">
                            <div class="imprint-grid">
                                <div class="imprint-item">
                                    <h4>Company</h4>
                                    <p>Raw Fiction e.U.</p>
                                </div>
                                
                                <div class="imprint-item">
                                    <h4>Owner</h4>
                                    <p>Raphael Hulan</p>
                                </div>
                                
                                <div class="imprint-item">
                                    <h4>Contact</h4>
                                    <p>+43 670 6066149</p>
                                </div>
                                
                                <div class="imprint-item">
                                    <h4>Company Registration</h4>
                                    <p>FN 519455f</p>
                                </div>
                                
                                <div class="imprint-item">
                                    <h4>VAT Number</h4>
                                    <p>ATU81854646</p>
                                </div>
                                
                                <div class="imprint-item">
                                    <h4>Commercial Court</h4>
                                    <p>Commercial Court Vienna</p>
                                </div>
                                
                                <div class="imprint-item">
                                    <h4>Chamber Membership</h4>
                                    <p>Vienna Chamber of Commerce</p>
                                </div>
                                
                                <div class="imprint-item">
                                    <h4>Business License</h4>
                                    <p>Advertising and Market Communication, Organization of Events, Markets and Fairs (Event Management)</p>
                                </div>
                                
                                <div class="imprint-item">
                                    <h4>Supervisory Authority</h4>
                                    <p>Municipal District Office for the 14th District</p>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                // Set the content
                detailsContent.innerHTML = defaultContent;
                
                // Scroll to top
                const scrollContainer = document.querySelector('.single-scrollable-container');
                if (scrollContainer) {
                    scrollContainer.scrollTop = 0;
                }
            }
        }
        
        // Initialize visualization when page loads
        window.addEventListener('DOMContentLoaded', () => {
            // First, set the panel state before creating the visualization
            const detailsPanel = document.getElementById('details-panel');
            const container = document.querySelector('.container');
            const legendPanel = document.getElementById('legend-panel');
            
            if (detailsPanel && container) {
                detailsPanel.classList.add('hidden');
                container.classList.add('panel-hidden');
                console.log("Panel state set before visualization creation");
            }
            
            // Initialize legend as hidden
            if (legendPanel) {
                legendPanel.classList.add('hidden');
                console.log("Legend state set before visualization creation");
            }
            
            // Small delay to ensure DOM changes are applied
            setTimeout(() => {
                const visualization = new AIAlignmentVisualization();
            }, 50);
        });
    </script>
</body>
</html>